<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://swaeldchen.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://swaeldchen.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-15T17:44:12+02:00</updated><id>https://swaeldchen.github.io/feed.xml</id><title type="html">blank</title><subtitle>Stephan Wäldchen - Researcher in Interpretable AI - This is my personal blog about new research, announcements and thoughts. </subtitle><entry><title type="html">Interactive Classification 3: Asymmetric Feature Correlation</title><link href="https://swaeldchen.github.io/blog/2023/FI_AFC/" rel="alternate" type="text/html" title="Interactive Classification 3: Asymmetric Feature Correlation"/><published>2023-01-04T00:00:00+01:00</published><updated>2023-01-04T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/FI_AFC</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/FI_AFC/"><![CDATA[\[\newcommand{\kl}[1]{\mathopen{}\left( #1 \right)\mathclose{}} \newcommand{\ekl}[1]{\mathopen{}\left[ #1 \right]\mathclose{}} \newcommand{\skl}[1]{\mathopen{}\left\{ #1 \right\}\mathclose{}} \newcommand{\bkl}[1]{\mathopen{}\left| #1 \right|\mathclose{}} \newcommand{\nkl}[1]{\mathopen{}\left\| #1 \right\|\mathclose{}} \newcommand{\bfa}{\mathbf{a}} \newcommand{\bfb}{\mathbf{b}} \newcommand{\bfc}{\mathbf{c}} \newcommand{\bfd}{\mathbf{d}} \newcommand{\bfe}{\mathbf{e}} \newcommand{\bff}{\mathbf{f}} \newcommand{\bfg}{\mathbf{g}} \newcommand{\bfh}{\mathbf{h}} \newcommand{\bfi}{\mathbf{i}} \newcommand{\bfj}{\mathbf{j}} \newcommand{\bfk}{\mathbf{k}} \newcommand{\bfl}{\mathbf{l}} \newcommand{\bfm}{\mathbf{m}} \newcommand{\bfn}{\mathbf{n}} \newcommand{\bfo}{\mathbf{o}} \newcommand{\bfp}{\mathbf{p}} \newcommand{\bfq}{\mathbf{q}} \newcommand{\bfr}{\mathbf{r}} \newcommand{\bfs}{\mathbf{s}} \newcommand{\bft}{\mathbf{t}} \newcommand{\bfu}{\mathbf{u}} \newcommand{\bfv}{\mathbf{v}} \newcommand{\bfw}{\mathbf{w}} \newcommand{\bfx}{\mathbf{x}} \newcommand{\bfy}{\mathbf{y}} \newcommand{\bfz}{\mathbf{z}} \newcommand{\bfA}{\mathbf{A}} \newcommand{\bfB}{\mathbf{B}} \newcommand{\bfC}{\mathbf{C}} \newcommand{\bfD}{\mathbf{D}} \newcommand{\bfE}{\mathbf{E}} \newcommand{\bfF}{\mathbf{F}} \newcommand{\bfG}{\mathbf{G}} \newcommand{\bfH}{\mathbf{H}} \newcommand{\bfI}{\mathbf{I}} \newcommand{\bfJ}{\mathbf{J}} \newcommand{\bfK}{\mathbf{K}} \newcommand{\bfL}{\mathbf{L}} \newcommand{\bfM}{\mathbf{M}} \newcommand{\bfN}{\mathbf{N}} \newcommand{\bfO}{\mathbf{O}} \newcommand{\bfP}{\mathbf{P}} \newcommand{\bfQ}{\mathbf{Q}} \newcommand{\bfR}{\mathbf{R}} \newcommand{\bfS}{\mathbf{S}} \newcommand{\bfT}{\mathbf{T}} \newcommand{\bfU}{\mathbf{U}} \newcommand{\bfV}{\mathbf{V}} \newcommand{\bfW}{\mathbf{W}} \newcommand{\bfX}{\mathbf{X}} \newcommand{\bfY}{\mathbf{Y}} \newcommand{\bfZ}{\mathbf{Z}} \newcommand{\bfone}{\mathbf{1}} \newcommand{\bfzero}{\mathbf{0}} \newcommand{\E}{\mathbb{E}} \newcommand{\R}{\mathbb{R}} \renewcommand{\P}{\mathbb{P}} \newcommand{\bfmu}{\bm{\mu}} \newcommand{\bfsigma}{\bm{\sigma}} \newcommand{\bfdelta}{\boldsymbol{\delta}} \newcommand{\bfSigma}{\bm{\Sigma}} \newcommand{\bfLambda}{\bm{\Lambda}} \newcommand{\bfeta}{\bm{\eta}} \newcommand{\bftheta}{\bm{\theta}} \newcommand{\CA}{\mathcal{A}} \newcommand{\CB}{\mathcal{B}} \newcommand{\CC}{\mathcal{C}} \newcommand{\CD}{\mathcal{D}} \newcommand{\CE}{\mathcal{E}} \newcommand{\CF}{\mathcal{F}} \newcommand{\CG}{\mathcal{G}} \newcommand{\CH}{\mathcal{H}} \newcommand{\CI}{\mathcal{I}} \newcommand{\CJ}{\mathcal{J}} \newcommand{\CK}{\mathcal{K}} \newcommand{\CL}{\mathcal{L}} \newcommand{\CM}{\mathcal{M}} \newcommand{\CN}{\mathcal{N}} \newcommand{\CO}{\mathcal{O}} \newcommand{\CP}{\mathcal{P}} \newcommand{\CQ}{\mathcal{Q}} \newcommand{\CR}{\mathcal{R}} \newcommand{\CS}{\mathcal{S}} \newcommand{\CT}{\mathcal{T}} \newcommand{\CU}{\mathcal{U}} \newcommand{\CV}{\mathcal{V}} \newcommand{\CW}{\mathcal{W}} \newcommand{\CX}{\mathcal{X}} \newcommand{\CY}{\mathcal{Y}} \newcommand{\CZ}{\mathcal{Z}} \newcommand{\frA}{\mathfrak{A}} \newcommand{\frB}{\mathfrak{B}} \newcommand{\frC}{\mathfrak{C}} \newcommand{\frD}{\mathfrak{D}} \newcommand{\frE}{\mathfrak{E}} \newcommand{\frF}{\mathfrak{F}} \newcommand{\frG}{\mathfrak{G}} \newcommand{\frH}{\mathfrak{H}} \newcommand{\frI}{\mathfrak{I}} \newcommand{\frJ}{\mathfrak{J}} \newcommand{\frK}{\mathfrak{K}} \newcommand{\frL}{\mathfrak{L}} \newcommand{\frM}{\mathfrak{M}} \newcommand{\frN}{\mathfrak{N}} \newcommand{\frO}{\mathfrak{O}} \newcommand{\frP}{\mathfrak{P}} \newcommand{\frQ}{\mathfrak{Q}} \newcommand{\frR}{\mathfrak{R}} \newcommand{\frS}{\mathfrak{S}} \newcommand{\frT}{\mathfrak{T}} \newcommand{\frU}{\mathfrak{U}} \newcommand{\frV}{\mathfrak{V}} \newcommand{\frW}{\mathfrak{W}} \newcommand{\frX}{\mathfrak{X}} \newcommand{\frY}{\mathfrak{Y}} \newcommand{\frZ}{\mathfrak{Z}} \newcommand{\CNP}{\mathcal{NP}} \newcommand{\CPP}{\mathcal{PP}} \newcommand{\SP}{\mathsf{P}} \newcommand{\SPP}{\mathsf{PP}} \newcommand{\SSP}{\mathsf{\#P}} \newcommand{\SNP}{\mathsf{NP}} \newcommand{\SBPP}{\mathsf{BPP}} \newcommand{\ScoNP}{\mathsf{coNP}} \newcommand{\bbone}{\mathbbm{1}} \newcommand{\ord}{\mathrm{ord}} \newcommand{\odr}{\vee} \newcommand{\und}{\wedge} \newcommand{\Odr}{\bigvee} \newcommand{\Und}{\bigwedge} \newcommand{\xor}{\oplus} \newcommand{\Xor}{\bigoplus} \newcommand{\bmat}[1]{\begin{bmatrix} #1 \end{bmatrix}} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\argmax}{argmax}\] <p>$\newcommand{\ap}{\text{Pr}}$ $\newcommand{\morg}{\widehat{M}}$</p> <style>.figcap{font-size:.9em}</style> <p>This post is part 3 of my series on <a href="/blog/2023/FI_start/">Interactive Classification</a>.</p> <p>*TL;DR: We give an intuitive understanding of Asymmetric Feature Correlation</p> <ol> <li>Asymmetric Feature Correlation</li> <li>Large AFC allows for Arthur-Merlin strategies that exchange uninformative features</li> <li>Exploiting AFC has a computational and a learnability barrier </li> </ol> <h3 id="asymmetric-feature-correlation">Asymmetric Feature Correlation</h3> <p>AFC describes a possible quirk of datasets, where a set of features is strongly concentrated in a few data points in one class and spread out over almost all data points in another. We give an illustrative example in Figure 1.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/afc.svg" alt="img1" style="float:center; width:100%"/> <p style="clear: both;"></p> </div> <p class="figcap"><br/> <strong>Figure 1.</strong> Example of a dataset an AFC $\kappa=6$. The ‘‘fruit’’ features are concentrated in one image for class $l=-1$ but spread out over six images for $l=1$ (vice versa for the ‘‘fish’’ features). Each individual feature is not indicative of the class as it appears exactly once in each class. Nevertheless, Arthur and Merlin can exchange ‘‘fruits’’ to indicate $l=1$ and ‘‘fish’’ for $l=-1$. The images where this strategy fails or can be exploited by Morgana are the two images on the left. Applyingour min-max theorem, we get $\epsilon_M = \frac{1}{7}$ and the set $D^{\prime}$ corresponds to all images with a single feature. Restricted to $D^{\prime}$, the features determine the class completely.</p> <p><strong>Possile Exploit:</strong> In this example, Merlin and Arthur can agree to exchange a fruit features to indicate class 1. Arthur can always be convinced by Merlin except in the one image with many fish. Likewise, the one image with the many fruit is the only one where he can be falsely convinced of class 1 by Morgana. This applies vice versa to class -1, where they exchange fish features. Thus the set $E_{M,\widehat{M},A}$ is only the two images on the left with the many features and</p> \[\epsilon_M = \frac{1}{7}.\] <p>But the features are individually uninformative! Each fish and fruit appear equally likely in both classes and thus $\ap_{\CD}(M)=\frac{1}{2}$. The bound</p> \[\ap_{\CD}(M) \geq 1-\epsilon_{M}\] <p>thus needs to fail. In fact, \(\epsilon_M\) can be made arbitrarily small as long as one can fit more features into the datapoints. This means that that the AFC necessarily has to be taken into account if we want to derive a bound on the informativeness of the features.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/select.svg" alt="img1" style="float:center; width:40%"/> <p style="clear: both;"></p> </div> <p class="figcap"><br/> <strong>Figure 1.</strong> Conditioned on any of the fish or fruit features the probability of being in either class are exactly the same. Thus the features are not informative of the class. Even so, they can be successfully leveraged by Merlin and Arthur.</p> <p>In the <a href="/blog/2023/FI_Merlin-Arthur/#a-min-max-theorem"> min-max theorem </a> we save ourselves by definiting the slightly smaller set $D^\prime$. In our example with the fruit and fish, $D^\prime$ is the set of all the images with a single feature. It is easy to check that this set covers a $1-\epsilon_M$ portion of the original set and that conditioned on it the fish and fruit features determine the class completely.</p> <p>If we want a bound that does not rely on a restricted set, we need to include the asymmetric feature correlation explicitely. We can formally define it as follows:</p> <p><strong>Asymmetric Feature Correlation:</strong> The AFC $\kappa$ of a dataset $D$ is defined as:</p> \[\kappa = \max_{l\in \{-1,1\}} \max_{F \subset \Sigma} \E_{\bfy \sim \CD_l|_{F^*}}\ekl{\max_{\substack{\phi \in F \\ \text{s.t. }\bfy \in \phi}}\kappa_l(\phi, F)}\] <p>with</p> \[\kappa_l(\phi, F) = \frac{\P_{\bfx \sim \CD_{-l}}\ekl{\bfx \in \phi \,\middle|\, \bfx \in F^*}}{\P_{\bfx \sim \CD_l}\ekl{\bfx \in \phi \,\middle|\, \bfx \in F^*}}.\] <p>where \(F^\ast := \left\{\bfx \in D~|~ \exists~ \phi \in F: \phi \subseteq \bfx\right\}\) is the set of all datapoins with a feature from $F$.</p> <p><strong>Intuition:</strong> The probability \(\P_{\bfx \sim \CD_{l}}\ekl{\bfx \in \phi \,\middle|\, \bfx \in F^*}\) for $\phi\in F$ is a measure of how correlated the features are. If all features appear in the same datapoints this quantity takes a maximal value of 1 for each $\phi$. If no features share the same datapoint the value is minimally $\frac{1}{\bkl{F}}$ for the average $\phi$. The $\kappa_l(\phi, F)$ thus measures the difference in correlation between the two classes. In the example in~\Cref{fig:afc} the worst-case $F$ for $l=-1$ correspond to the ‘‘fish’’ features and $\kappa_l(\phi, F)=6$ for each feature. To take an expectation over the features $\phi$ requires a distribution, so we take the distribution of datapoints that have a feature from $F$, i.e. $\bfy \sim \CD_l|_{F^*}$, and select the worst-case feature from each datapoint. Then we maximise over class and the possible feature sets $F$. Since, in Figure 5, the ‘‘fish’’ and ‘‘fruit’’ features are the worst case for each class respectively, we arrive at an AFC of 6.</p> <p>This definition allows us to later state our main theorem.</p> <h4 id="how-large-can-the-afc-get">How large can the AFC get?</h4> <p>In the fish-and-fruit example we created an AFC of six by putting six features into a single image. As it turns out, one can actually prove that the maximum number of features per datapoint upper bounds the AFC.</p> <p><strong>Lemma</strong> Let $D$ be a dataset with feature space $\Sigma$ and AFC of $\kappa$. Let \(K = \max_{\bfx \in D}\, \bkl{\skl{\phi \in \Sigma \,|\, \bfx \in \phi}}\) be the maximum number of features per data point. Then</p> \[\kappa \leq K.\] <p>The maximum number of features per datapoint depends on the feature space $\Sigma$. For example, text data of sentences of length $d$, where every consecutive set of words is a feature, have a maximum feature count of $d^2$. However, when we consider every valid subset of input parameters of a datapoint as a possible feature for Merlin and Arthur to exchange, $K$ becomes exponential in the input dimension and is easy to construct an example dataset with an exponentially large AFC.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/red_and_blue.svg" alt="img1" style="float:center; width:100%"/> <p style="clear: both;"></p> </div> <p class="figcap"><br/> <strong>Figure 1.</strong> An example of a dataset with very high asymmetric feature correlation. The completely red image shares a feature with each of the $m$-red-pixel images (here $m=5$), of which there are $\binom{d}{m}$ many. In the worst case $m=\frac{d}{2}$, resulting in $k=\binom{d}{d/2}$ thus exponential growth in $d$.</p> <p><br/></p> <p>I expect the AFC in real-world datasets to be likely small, much smaller than exponential in the input dimension. But even if a dataset has in principle a large AFC, there are two barriers that Merlin and Arthur need to overcome if they want to exploit it.</p> <p>First, they need to find a set of features that realises the large AFC, which is a computationally hard problem. Second, the features they select need to generalise to the test dataset on which completeness and soundness are evaluated.</p> <h4 id="computational-hardness">Computational Hardness</h4> <p>Just as it is computationally hard to determine the AFC of a dataset, it is also computationally hard to exploit. This holds at least if one wants to come close to the optimal level, as we show in our recent <a href="https://arxiv.org/pdf/2306.04505.pdf">paper</a>. We formalise the dataset with the feature space as a tri-partite graph. The problem of Merlin and Arthur deceptively choosing feature with low precision to ensure high completeness and soundness can then be modelled as a graph problem. We prove that this problem ist (expectedly) $\SNP$-hard, but also give an inapproximability barrier.</p> <p>This does not, however, mean that the problem will be hard on average, as this is a worst-case complexity analysis. Rather, it shows that determining the AFC is as hard as exploiting it. We will come back to this point in the last post in this series.</p> <h4 id="learnability">Learnability</h4> <p>Learnability is another barrier to exploit the AFC. Merlin and Arthur’s strategy needs to carry over from the train to the test dataset. That means: They might find some clever set of features by optimising over the train dataset, but if this set does not generalis to the test datset they will not achieve high completeness and soundness there.</p> <p>So far, however, this has analysis is highly speculative and has not been verified in real-world dataset.</p> <h3 id="key-takeaways">Key Takeaways</h3> <p>The above theoretical discussion shows two key contributions of our framework.</p> <ol> <li>The Asymmetric Feature Correlation is a necessary consideration of a dataset to connect Merlin-Arthur completeness and soundness with high feature precision</li> <li>We do not expect this issue in practice for the following reasons: <ol> <li>The AFC can be circumvented using a slightly reduced dataset as in the min-max Theorem,</li> <li>Exploiting the AFC faces a computational and a learnability barrier.</li> </ol> </li> </ol> <p><a href="/blog/2023/FI_Merlin-Arthur/">◀ Previous Post</a></p> <p align="right"><a href="/blog/2023/FI_Relative_Strength/" align="right"> Next Post &#9654;</a></p> <ol class="bibliography"></ol>]]></content><author><name>Stephan Wäldchen</name></author><category term="research"/><category term="optimization"/><category term="ml"/><category term="uniform convexity"/><category term="abstract"/><summary type="html"><![CDATA[\[\newcommand{\kl}[1]{\mathopen{}\left( #1 \right)\mathclose{}} \newcommand{\ekl}[1]{\mathopen{}\left[ #1 \right]\mathclose{}} \newcommand{\skl}[1]{\mathopen{}\left\{ #1 \right\}\mathclose{}} \newcommand{\bkl}[1]{\mathopen{}\left| #1 \right|\mathclose{}} \newcommand{\nkl}[1]{\mathopen{}\left\| #1 \right\|\mathclose{}} \newcommand{\bfa}{\mathbf{a}} \newcommand{\bfb}{\mathbf{b}} \newcommand{\bfc}{\mathbf{c}} \newcommand{\bfd}{\mathbf{d}} \newcommand{\bfe}{\mathbf{e}} \newcommand{\bff}{\mathbf{f}} \newcommand{\bfg}{\mathbf{g}} \newcommand{\bfh}{\mathbf{h}} \newcommand{\bfi}{\mathbf{i}} \newcommand{\bfj}{\mathbf{j}} \newcommand{\bfk}{\mathbf{k}} \newcommand{\bfl}{\mathbf{l}} \newcommand{\bfm}{\mathbf{m}} \newcommand{\bfn}{\mathbf{n}} \newcommand{\bfo}{\mathbf{o}} \newcommand{\bfp}{\mathbf{p}} \newcommand{\bfq}{\mathbf{q}} \newcommand{\bfr}{\mathbf{r}} \newcommand{\bfs}{\mathbf{s}} \newcommand{\bft}{\mathbf{t}} \newcommand{\bfu}{\mathbf{u}} \newcommand{\bfv}{\mathbf{v}} \newcommand{\bfw}{\mathbf{w}} \newcommand{\bfx}{\mathbf{x}} \newcommand{\bfy}{\mathbf{y}} \newcommand{\bfz}{\mathbf{z}} \newcommand{\bfA}{\mathbf{A}} \newcommand{\bfB}{\mathbf{B}} \newcommand{\bfC}{\mathbf{C}} \newcommand{\bfD}{\mathbf{D}} \newcommand{\bfE}{\mathbf{E}} \newcommand{\bfF}{\mathbf{F}} \newcommand{\bfG}{\mathbf{G}} \newcommand{\bfH}{\mathbf{H}} \newcommand{\bfI}{\mathbf{I}} \newcommand{\bfJ}{\mathbf{J}} \newcommand{\bfK}{\mathbf{K}} \newcommand{\bfL}{\mathbf{L}} \newcommand{\bfM}{\mathbf{M}} \newcommand{\bfN}{\mathbf{N}} \newcommand{\bfO}{\mathbf{O}} \newcommand{\bfP}{\mathbf{P}} \newcommand{\bfQ}{\mathbf{Q}} \newcommand{\bfR}{\mathbf{R}} \newcommand{\bfS}{\mathbf{S}} \newcommand{\bfT}{\mathbf{T}} \newcommand{\bfU}{\mathbf{U}} \newcommand{\bfV}{\mathbf{V}} \newcommand{\bfW}{\mathbf{W}} \newcommand{\bfX}{\mathbf{X}} \newcommand{\bfY}{\mathbf{Y}} \newcommand{\bfZ}{\mathbf{Z}} \newcommand{\bfone}{\mathbf{1}} \newcommand{\bfzero}{\mathbf{0}} \newcommand{\E}{\mathbb{E}} \newcommand{\R}{\mathbb{R}} \renewcommand{\P}{\mathbb{P}} \newcommand{\bfmu}{\bm{\mu}} \newcommand{\bfsigma}{\bm{\sigma}} \newcommand{\bfdelta}{\boldsymbol{\delta}} \newcommand{\bfSigma}{\bm{\Sigma}} \newcommand{\bfLambda}{\bm{\Lambda}} \newcommand{\bfeta}{\bm{\eta}} \newcommand{\bftheta}{\bm{\theta}} \newcommand{\CA}{\mathcal{A}} \newcommand{\CB}{\mathcal{B}} \newcommand{\CC}{\mathcal{C}} \newcommand{\CD}{\mathcal{D}} \newcommand{\CE}{\mathcal{E}} \newcommand{\CF}{\mathcal{F}} \newcommand{\CG}{\mathcal{G}} \newcommand{\CH}{\mathcal{H}} \newcommand{\CI}{\mathcal{I}} \newcommand{\CJ}{\mathcal{J}} \newcommand{\CK}{\mathcal{K}} \newcommand{\CL}{\mathcal{L}} \newcommand{\CM}{\mathcal{M}} \newcommand{\CN}{\mathcal{N}} \newcommand{\CO}{\mathcal{O}} \newcommand{\CP}{\mathcal{P}} \newcommand{\CQ}{\mathcal{Q}} \newcommand{\CR}{\mathcal{R}} \newcommand{\CS}{\mathcal{S}} \newcommand{\CT}{\mathcal{T}} \newcommand{\CU}{\mathcal{U}} \newcommand{\CV}{\mathcal{V}} \newcommand{\CW}{\mathcal{W}} \newcommand{\CX}{\mathcal{X}} \newcommand{\CY}{\mathcal{Y}} \newcommand{\CZ}{\mathcal{Z}} \newcommand{\frA}{\mathfrak{A}} \newcommand{\frB}{\mathfrak{B}} \newcommand{\frC}{\mathfrak{C}} \newcommand{\frD}{\mathfrak{D}} \newcommand{\frE}{\mathfrak{E}} \newcommand{\frF}{\mathfrak{F}} \newcommand{\frG}{\mathfrak{G}} \newcommand{\frH}{\mathfrak{H}} \newcommand{\frI}{\mathfrak{I}} \newcommand{\frJ}{\mathfrak{J}} \newcommand{\frK}{\mathfrak{K}} \newcommand{\frL}{\mathfrak{L}} \newcommand{\frM}{\mathfrak{M}} \newcommand{\frN}{\mathfrak{N}} \newcommand{\frO}{\mathfrak{O}} \newcommand{\frP}{\mathfrak{P}} \newcommand{\frQ}{\mathfrak{Q}} \newcommand{\frR}{\mathfrak{R}} \newcommand{\frS}{\mathfrak{S}} \newcommand{\frT}{\mathfrak{T}} \newcommand{\frU}{\mathfrak{U}} \newcommand{\frV}{\mathfrak{V}} \newcommand{\frW}{\mathfrak{W}} \newcommand{\frX}{\mathfrak{X}} \newcommand{\frY}{\mathfrak{Y}} \newcommand{\frZ}{\mathfrak{Z}} \newcommand{\CNP}{\mathcal{NP}} \newcommand{\CPP}{\mathcal{PP}} \newcommand{\SP}{\mathsf{P}} \newcommand{\SPP}{\mathsf{PP}} \newcommand{\SSP}{\mathsf{\#P}} \newcommand{\SNP}{\mathsf{NP}} \newcommand{\SBPP}{\mathsf{BPP}} \newcommand{\ScoNP}{\mathsf{coNP}} \newcommand{\bbone}{\mathbbm{1}} \newcommand{\ord}{\mathrm{ord}} \newcommand{\odr}{\vee} \newcommand{\und}{\wedge} \newcommand{\Odr}{\bigvee} \newcommand{\Und}{\bigwedge} \newcommand{\xor}{\oplus} \newcommand{\Xor}{\bigoplus} \newcommand{\bmat}[1]{\begin{bmatrix} #1 \end{bmatrix}} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\argmax}{argmax}\]]]></summary></entry><entry><title type="html">Interactive Classification 2: Prover-Verifier Setup</title><link href="https://swaeldchen.github.io/blog/2023/FI_Merlin-Arthur/" rel="alternate" type="text/html" title="Interactive Classification 2: Prover-Verifier Setup"/><published>2023-01-04T00:00:00+01:00</published><updated>2023-01-04T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/FI_Merlin-Arthur</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/FI_Merlin-Arthur/"><![CDATA[\[\newcommand{\kl}[1]{\mathopen{}\left( #1 \right)\mathclose{}} \newcommand{\ekl}[1]{\mathopen{}\left[ #1 \right]\mathclose{}} \newcommand{\skl}[1]{\mathopen{}\left\{ #1 \right\}\mathclose{}} \newcommand{\bkl}[1]{\mathopen{}\left| #1 \right|\mathclose{}} \newcommand{\nkl}[1]{\mathopen{}\left\| #1 \right\|\mathclose{}} \newcommand{\bfa}{\mathbf{a}} \newcommand{\bfb}{\mathbf{b}} \newcommand{\bfc}{\mathbf{c}} \newcommand{\bfd}{\mathbf{d}} \newcommand{\bfe}{\mathbf{e}} \newcommand{\bff}{\mathbf{f}} \newcommand{\bfg}{\mathbf{g}} \newcommand{\bfh}{\mathbf{h}} \newcommand{\bfi}{\mathbf{i}} \newcommand{\bfj}{\mathbf{j}} \newcommand{\bfk}{\mathbf{k}} \newcommand{\bfl}{\mathbf{l}} \newcommand{\bfm}{\mathbf{m}} \newcommand{\bfn}{\mathbf{n}} \newcommand{\bfo}{\mathbf{o}} \newcommand{\bfp}{\mathbf{p}} \newcommand{\bfq}{\mathbf{q}} \newcommand{\bfr}{\mathbf{r}} \newcommand{\bfs}{\mathbf{s}} \newcommand{\bft}{\mathbf{t}} \newcommand{\bfu}{\mathbf{u}} \newcommand{\bfv}{\mathbf{v}} \newcommand{\bfw}{\mathbf{w}} \newcommand{\bfx}{\mathbf{x}} \newcommand{\bfy}{\mathbf{y}} \newcommand{\bfz}{\mathbf{z}} \newcommand{\bfA}{\mathbf{A}} \newcommand{\bfB}{\mathbf{B}} \newcommand{\bfC}{\mathbf{C}} \newcommand{\bfD}{\mathbf{D}} \newcommand{\bfE}{\mathbf{E}} \newcommand{\bfF}{\mathbf{F}} \newcommand{\bfG}{\mathbf{G}} \newcommand{\bfH}{\mathbf{H}} \newcommand{\bfI}{\mathbf{I}} \newcommand{\bfJ}{\mathbf{J}} \newcommand{\bfK}{\mathbf{K}} \newcommand{\bfL}{\mathbf{L}} \newcommand{\bfM}{\mathbf{M}} \newcommand{\bfN}{\mathbf{N}} \newcommand{\bfO}{\mathbf{O}} \newcommand{\bfP}{\mathbf{P}} \newcommand{\bfQ}{\mathbf{Q}} \newcommand{\bfR}{\mathbf{R}} \newcommand{\bfS}{\mathbf{S}} \newcommand{\bfT}{\mathbf{T}} \newcommand{\bfU}{\mathbf{U}} \newcommand{\bfV}{\mathbf{V}} \newcommand{\bfW}{\mathbf{W}} \newcommand{\bfX}{\mathbf{X}} \newcommand{\bfY}{\mathbf{Y}} \newcommand{\bfZ}{\mathbf{Z}} \newcommand{\bfone}{\mathbf{1}} \newcommand{\bfzero}{\mathbf{0}} \newcommand{\E}{\mathbb{E}} \newcommand{\R}{\mathbb{R}} \renewcommand{\P}{\mathbb{P}} \newcommand{\bfmu}{\bm{\mu}} \newcommand{\bfsigma}{\bm{\sigma}} \newcommand{\bfdelta}{\boldsymbol{\delta}} \newcommand{\bfSigma}{\bm{\Sigma}} \newcommand{\bfLambda}{\bm{\Lambda}} \newcommand{\bfeta}{\bm{\eta}} \newcommand{\bftheta}{\bm{\theta}} \newcommand{\CA}{\mathcal{A}} \newcommand{\CB}{\mathcal{B}} \newcommand{\CC}{\mathcal{C}} \newcommand{\CD}{\mathcal{D}} \newcommand{\CE}{\mathcal{E}} \newcommand{\CF}{\mathcal{F}} \newcommand{\CG}{\mathcal{G}} \newcommand{\CH}{\mathcal{H}} \newcommand{\CI}{\mathcal{I}} \newcommand{\CJ}{\mathcal{J}} \newcommand{\CK}{\mathcal{K}} \newcommand{\CL}{\mathcal{L}} \newcommand{\CM}{\mathcal{M}} \newcommand{\CN}{\mathcal{N}} \newcommand{\CO}{\mathcal{O}} \newcommand{\CP}{\mathcal{P}} \newcommand{\CQ}{\mathcal{Q}} \newcommand{\CR}{\mathcal{R}} \newcommand{\CS}{\mathcal{S}} \newcommand{\CT}{\mathcal{T}} \newcommand{\CU}{\mathcal{U}} \newcommand{\CV}{\mathcal{V}} \newcommand{\CW}{\mathcal{W}} \newcommand{\CX}{\mathcal{X}} \newcommand{\CY}{\mathcal{Y}} \newcommand{\CZ}{\mathcal{Z}} \newcommand{\frA}{\mathfrak{A}} \newcommand{\frB}{\mathfrak{B}} \newcommand{\frC}{\mathfrak{C}} \newcommand{\frD}{\mathfrak{D}} \newcommand{\frE}{\mathfrak{E}} \newcommand{\frF}{\mathfrak{F}} \newcommand{\frG}{\mathfrak{G}} \newcommand{\frH}{\mathfrak{H}} \newcommand{\frI}{\mathfrak{I}} \newcommand{\frJ}{\mathfrak{J}} \newcommand{\frK}{\mathfrak{K}} \newcommand{\frL}{\mathfrak{L}} \newcommand{\frM}{\mathfrak{M}} \newcommand{\frN}{\mathfrak{N}} \newcommand{\frO}{\mathfrak{O}} \newcommand{\frP}{\mathfrak{P}} \newcommand{\frQ}{\mathfrak{Q}} \newcommand{\frR}{\mathfrak{R}} \newcommand{\frS}{\mathfrak{S}} \newcommand{\frT}{\mathfrak{T}} \newcommand{\frU}{\mathfrak{U}} \newcommand{\frV}{\mathfrak{V}} \newcommand{\frW}{\mathfrak{W}} \newcommand{\frX}{\mathfrak{X}} \newcommand{\frY}{\mathfrak{Y}} \newcommand{\frZ}{\mathfrak{Z}} \newcommand{\CNP}{\mathcal{NP}} \newcommand{\CPP}{\mathcal{PP}} \newcommand{\SP}{\mathsf{P}} \newcommand{\SPP}{\mathsf{PP}} \newcommand{\SSP}{\mathsf{\#P}} \newcommand{\SNP}{\mathsf{NP}} \newcommand{\SBPP}{\mathsf{BPP}} \newcommand{\ScoNP}{\mathsf{coNP}} \newcommand{\bbone}{\mathbbm{1}} \newcommand{\ord}{\mathrm{ord}} \newcommand{\odr}{\vee} \newcommand{\und}{\wedge} \newcommand{\Odr}{\bigvee} \newcommand{\Und}{\bigwedge} \newcommand{\xor}{\oplus} \newcommand{\Xor}{\bigoplus} \newcommand{\bmat}[1]{\begin{bmatrix} #1 \end{bmatrix}} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\argmax}{argmax}\] <p>$\newcommand{\ap}{\text{Pr}}$ $\newcommand{\morg}{\widehat{M}}$</p> <style>.figcap{font-size:.9em}</style> <p>This post is part 2 of my series on <a href="/blog/2023/FI_start/">Interactive Classification</a>.</p> <p>*TL;DR: We present interactive classification as an approach to define informative features without modelling the data distribution explicitly</p> <ol> <li>Why we need an adversarial aspect to the prover</li> <li>Abstract definition of features</li> <li>A min-max theorem </li> </ol> <p>In <a href="/blog/2023/FI_Preliminaries/">a previous post</a> we discussed why it is difficult to model the conditional data distribution. This distribution is used to define feature importance according to high Mutual Information or Shapley Values. Now, we explain how this issue can be circumvented by designing an inherently interpretable classifier through an interactive classification setup. This setup will allow us to derive lower bounds on the <strong>precision</strong> of the features in terms of quantities that can be easily estimated on a dataset. <a class="citation" href="#lundberg2017unified">(Lundberg &amp; Lee, 2017)</a></p> <h3 id="interactive-classification">Interactive Classification</h3> <p>The inspiration for interactive classification comes from Interactive Proof Systems (IPS), a concept from Complexity Theory, specifically the <a href="https://en.wikipedia.org/wiki/Arthur%E2%80%93Merlin_protocol#MA">Merlin-Arthur protocol</a>. The prover (<strong>Merlin</strong>) selects a feature from the datapoint and sends it to the verifier (<strong>Arthur</strong>) who decides the class.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/concept.svg" alt="img1" style="float:center; width:50%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 1.</strong> An example of a decision list taken from <a class="citation" href="#rudin2019stop">(Rudin, 2019)</a> used to predict whether a delinquent will be arrested again. The reasoning of the decision list is directly readable.)</p> <p>Crucially, in IPS the prover is unreliable, sometimes trying to convince the verifier of a wrong judgement. We mirror this by having a second prover, <strong>Morgana</strong>, that tries to get Arthur to say the wrong class. Arthur is allowed to say “Don’t know!” and thus refraining from classification. In this context, we can then translate the concepts of <em>completeness</em> and <em>soundness</em> from IPS to our setting.</p> <ul> <li><strong>Completeness:</strong> describes the probability that Arthur classifies correctly based on features from Merlin.</li> <li><strong>Soundness:</strong> is the probability that Arthur does not get fooled by Morgana, thus either giving the correct class or answering ‘‘Don’t know!’’.</li> </ul> <p>These two quantities can be measured on a finite dataset and are used to lower bound the information contained in features selected by Merlin. Since these are simple scalar quantities, one can easily estimate them on the test set similar to the test accuracy of a normal classifier.</p> <h3 id="cheating-with-cooperative-prover-and-verfier">Cheating with cooperative Prover and Verfier</h3> <p>Interactive classification had been introduced earlier in <a class="citation" href="#lei2016rationalizing">(Lei et al., 2016)</a> and <a class="citation" href="#bastings2019interpretable">(Bastings et al., 2019)</a> – without an adversarial aspect. It was then noted in <a class="citation" href="#lei2016rationalizing">(Lei et al., 2016)</a> that in that case Merlin and Arthur can “cheat” and use uninformative features to communicate the class, as illustrated in Figure 1.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/cheating.svg" alt="img1" style="float:center; width:50%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 2.</strong> An example of a decision list taken from <a class="citation" href="#rudin2019stop">(Rudin, 2019)</a> used to predict whether a delinquent will be arrested again. The reasoning of the decision list is directly readable.)</p> <p>If prover and verifier are purely cooperative, Merlin can decide the class and communicate it over an arbitrary code! The feature selected for this code need not have anything to do with the features that Merlin used to decide the class. See Figure 1 for an Illustration. We showed that this happens in practice in …</p> <p>However, any such strategy can be exploited by an adversarial prover (Morgana) to convince Arthur of the wrong class. The intuition is this: Let us assume the verifier accepts a feature as proof of a class that is uncorrelated with the class. Then this feature must also appear in datapoints of a different class. Morgana can then select this feature in the different class and convince the Arthur to give the wrong classification.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/strategy.svg" alt="img1" style="float:center; width:100%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 3.</strong> An example of a decision list taken from <a class="citation" href="#rudin2019stop">(Rudin, 2019)</a> used to predict whether a delinquent will be arrested again. The reasoning of the decision list is directly readable.)</p> <p>Now we want to pack this intuition into theory!</p> <h3 id="theoretical-setup">Theoretical Setup</h3> <p>What exactly constitutes a feature can be up for debate. Most common are features that are defined as partial input vectors, like a cutout from an image. There are more abstract definitions such as anchors <a class="citation" href="#ribeiro2018anchors">(Ribeiro et al., 2018)</a> or queries <a class="citation" href="#chen2018learning">(Chen et al., 2018)</a>. Here, we leave our features completely abstract and define them as a set of datapoints. This can be interpreted as the set of datapoints that contain the feature, see Figure 4 for an illustration.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/house.svg" alt="img1" style="float:center; width:50%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 4.</strong> An example of a feature defined in two different ways: on the left via concrete pixel values, on the right as a set of all images that have these pixel values. The set definition, however, allows to construct much more general features. We can, for example, include shifts and rotations of the pixel values, as well as other transformations, by expanding the set.</p> <p>So form now on we assume that our data space $D$ comes equipped with a feature space $\Sigma \subset 2^{D}$, which is a set of subsets of $D$. In terms of precision (see <a href="/blog/2023/FI_Preliminaries/">former post</a>) we can say that a feature has high precision if it contains datapoints mostly belonging to the same class. Such a feature is highly informative of the class.</p> <h4 id="definitions-for-prover-feature-selector-and-verifier-feature-classifier">Definitions for Prover (Feature Selector) and Verifier (Feature Classifier)</h4> <p><strong>Feature Selector:</strong> For a given dataset $D$, we define a <em>feature selector</em> as a map $M:D \rightarrow \Sigma$ such that for all $\bfx \in D$ we have $ \bfx \in M(\bfx)$. This means that for every data point $\bfx \in D$ the feature selector $M$ chooses a feature that is present in $\bfx$. We call $\CM(D)$ the space of all feature selectors for a dataset $D$.</p> <p><strong>Feature Classifier:</strong> We define a <em>feature classifier</em> for a dataset $D$ as a function \(A: \Sigma \rightarrow \{-1,0,1\}\).Here, $0$ corresponds to the situation where the classifier is unable to identify a correct class. We call the space of all feature classifiers $\CA$.</p> <p>We can extend the definition of the precision of a feature to the expected precision of a feature selector, which will allows us to evaluate the quality of the feature selectors and measure the performance of our framework.</p> \[\ap_{\CD}(M) := \E_{\bfx\sim \CD} \ekl{\P_{\bfy\sim\CD}\ekl{c(\bfy) = c(\bfx) \,|\, M(\bfx) \subseteq \bfy}}.\] <p>The expected precision $\ap_{\CD}(M)$ can be used to bound the expected conditional entropy and mutual information of the features identified by Merlin.</p> \[\E_{\bfx \sim \CD} [I_{\bfy\sim\CD}(c(\bfy); M(\bfx) \subseteq \bfy)] \geq H_{\bfy\sim\CD}(c(\bfy)) - H_b(\ap_{\CD}(M)).\] <p>We can now state our first result of our investigation.</p> <h4 id="a-min-max-theorem">A Min-Max Theorem:</h4> <p>For a feature classifier $A$ (Arthur) and two feature selectors $M$ (Merlin) and $\widehat{M}$ (Morgana) we define</p> \[E_{M,\widehat{M},A} := \{x \in D\,|\, A(M(\bfx)) \neq c(\bfx) ~\lor~ A(\widehat{M}(\bfx)) = -c(\bfx)\},\] <p>which is the set of all datapoints where either Merlin cannot convince Arthur of the right class, or Morgana can convince him of the wrong class, in short, the datapoints where Arthur fails.</p> <p><strong>Min-Max Theorem:</strong> Let $M\in \CM(D)$ be a feature selector and let</p> \[\epsilon_M = \min_{A \in \CA} \max_{\widehat{M} \in \CM} \,\P_{\bfx\sim \CD}\ekl{\bfx \in E_{M,\widehat{M},A}}.\] <p>Then a set $D^{\prime}\subset D$ with $\P_{\bfx\sim \CD}\ekl{\bfx \in D^\prime} \geq 1-\epsilon_M$ exists such that for \(\CD^\prime = \CD|_{D^\prime}\). we have</p> \[\ap_{\CD^\prime}(M) = 1, \quad \text{thus}\quad H_{\bfx,\bfy\sim\CD^\prime}(c(\bfy) \;|\; \bfy \in M(\bfx)) = 0.\] <p>This means that, if Merlin and Arthur cooperate successfully (i.e. small $\epsilon_M$), then there is a set that covers almost the whole original set (up to $\epsilon_M$) conditioned on which the features selected by Merlin determine the class perfectly.</p> <p>Now, the formulation of this theorem is a bit curious. Why can we not directly state something like</p> \[\ap_{\CD}(M) \geq 1-\epsilon_{M}?\] <p>The problem lies in a potential quirk in the dataset that makes it hard to connect the informativeness of the whole feature set to the individual features. We explore this more in the next post about the <a href="/blog/2023/FI_AFC/">Asymmetric Feature Correlation</a>.</p> <h4 id="comparison-with-adversarial-robustness">Comparison with Adversarial Robustness</h4> <p>Robustness with respect to Morgana can be seen as a type of adversarial robustness. We recall that the objective of the regular adversary is</p> \[\argmax_{\nkl{\bfdelta} \leq \epsilon} L(\bfx + \bfdelta).\] <p>The underlying interpretation is: “Changing the input by an imperceptible amount should not convince the classifier of a different class.” The interpretation of robustness against Morgana is: “Covering parts of the input should not convince the classifier of a different class.” Or even more plainly, covering parts of a dog image should not convince the classifier or a cat. At most the classifier becomes unsure and refuses to classify. It is thus a natural robustness that we should expect from well-generalising classifiers.</p> <h3 id="key-insights">Key Insights:</h3> <ol> <li>Without an adversarial prover, Merlin and Arthur can communicate through an arbitrary code of features that are unrelated to the true class.</li> <li>We can derive a min-max theorem that connects the completeness and soundness of Arthur and Merlin’s strategy to the informativeness of the features.</li> <li>The robustness against the Morgana adversary is reasonable and necessary to generalise to partially hidden objects.</li> </ol> <p><a href="/blog/2023/FI_Preliminaries/">◀ Previous Post</a></p> <p align="right"><a href="/blog/2023/FI_AFC/" align="right"> Next Post &#9654;</a></p> <h3 id="references">References</h3> <ol class="bibliography"><li><div class="text-justify"> <span id="lundberg2017unified">Lundberg, S. M., &amp; Lee, S.-I. (2017). A unified approach to interpreting model predictions. <i>Advances in Neural Information Processing Systems</i>, <i>30</i>.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="rudin2019stop">Rudin, C. (2019). Stop explaining black box machine learning models for high stakes decisions and use interpretable models instead. <i>Nature Machine Intelligence</i>, <i>1</i>(5), 206–215.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="lei2016rationalizing">Lei, T., Barzilay, R., &amp; Jaakkola, T. (2016). Rationalizing neural predictions. <i>ArXiv Preprint ArXiv:1606.04155</i>.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="bastings2019interpretable">Bastings, J., Aziz, W., &amp; Titov, I. (2019). Interpretable neural predictions with differentiable binary variables. <i>ArXiv Preprint ArXiv:1905.08160</i>, 2963–2977.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="ribeiro2018anchors">Ribeiro, M. T., Singh, S., &amp; Guestrin, C. (2018). Anchors: High-precision model-agnostic explanations. <i>Proceedings of the AAAI Conference on Artificial Intelligence</i>, <i>32</i>(1).</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="chen2018learning">Chen, J., Song, L., Wainwright, M., &amp; Jordan, M. (2018). Learning to explain: An information-theoretic perspective on model interpretation. <i>International Conference on Machine Learning</i>, 883–892.</span> </div> <div> </div> <div> </div> </li></ol>]]></content><author><name>Stephan Wäldchen</name></author><category term="research"/><category term="optimization"/><category term="ml"/><category term="uniform convexity"/><category term="abstract"/><summary type="html"><![CDATA[\[\newcommand{\kl}[1]{\mathopen{}\left( #1 \right)\mathclose{}} \newcommand{\ekl}[1]{\mathopen{}\left[ #1 \right]\mathclose{}} \newcommand{\skl}[1]{\mathopen{}\left\{ #1 \right\}\mathclose{}} \newcommand{\bkl}[1]{\mathopen{}\left| #1 \right|\mathclose{}} \newcommand{\nkl}[1]{\mathopen{}\left\| #1 \right\|\mathclose{}} \newcommand{\bfa}{\mathbf{a}} \newcommand{\bfb}{\mathbf{b}} \newcommand{\bfc}{\mathbf{c}} \newcommand{\bfd}{\mathbf{d}} \newcommand{\bfe}{\mathbf{e}} \newcommand{\bff}{\mathbf{f}} \newcommand{\bfg}{\mathbf{g}} \newcommand{\bfh}{\mathbf{h}} \newcommand{\bfi}{\mathbf{i}} \newcommand{\bfj}{\mathbf{j}} \newcommand{\bfk}{\mathbf{k}} \newcommand{\bfl}{\mathbf{l}} \newcommand{\bfm}{\mathbf{m}} \newcommand{\bfn}{\mathbf{n}} \newcommand{\bfo}{\mathbf{o}} \newcommand{\bfp}{\mathbf{p}} \newcommand{\bfq}{\mathbf{q}} \newcommand{\bfr}{\mathbf{r}} \newcommand{\bfs}{\mathbf{s}} \newcommand{\bft}{\mathbf{t}} \newcommand{\bfu}{\mathbf{u}} \newcommand{\bfv}{\mathbf{v}} \newcommand{\bfw}{\mathbf{w}} \newcommand{\bfx}{\mathbf{x}} \newcommand{\bfy}{\mathbf{y}} \newcommand{\bfz}{\mathbf{z}} \newcommand{\bfA}{\mathbf{A}} \newcommand{\bfB}{\mathbf{B}} \newcommand{\bfC}{\mathbf{C}} \newcommand{\bfD}{\mathbf{D}} \newcommand{\bfE}{\mathbf{E}} \newcommand{\bfF}{\mathbf{F}} \newcommand{\bfG}{\mathbf{G}} \newcommand{\bfH}{\mathbf{H}} \newcommand{\bfI}{\mathbf{I}} \newcommand{\bfJ}{\mathbf{J}} \newcommand{\bfK}{\mathbf{K}} \newcommand{\bfL}{\mathbf{L}} \newcommand{\bfM}{\mathbf{M}} \newcommand{\bfN}{\mathbf{N}} \newcommand{\bfO}{\mathbf{O}} \newcommand{\bfP}{\mathbf{P}} \newcommand{\bfQ}{\mathbf{Q}} \newcommand{\bfR}{\mathbf{R}} \newcommand{\bfS}{\mathbf{S}} \newcommand{\bfT}{\mathbf{T}} \newcommand{\bfU}{\mathbf{U}} \newcommand{\bfV}{\mathbf{V}} \newcommand{\bfW}{\mathbf{W}} \newcommand{\bfX}{\mathbf{X}} \newcommand{\bfY}{\mathbf{Y}} \newcommand{\bfZ}{\mathbf{Z}} \newcommand{\bfone}{\mathbf{1}} \newcommand{\bfzero}{\mathbf{0}} \newcommand{\E}{\mathbb{E}} \newcommand{\R}{\mathbb{R}} \renewcommand{\P}{\mathbb{P}} \newcommand{\bfmu}{\bm{\mu}} \newcommand{\bfsigma}{\bm{\sigma}} \newcommand{\bfdelta}{\boldsymbol{\delta}} \newcommand{\bfSigma}{\bm{\Sigma}} \newcommand{\bfLambda}{\bm{\Lambda}} \newcommand{\bfeta}{\bm{\eta}} \newcommand{\bftheta}{\bm{\theta}} \newcommand{\CA}{\mathcal{A}} \newcommand{\CB}{\mathcal{B}} \newcommand{\CC}{\mathcal{C}} \newcommand{\CD}{\mathcal{D}} \newcommand{\CE}{\mathcal{E}} \newcommand{\CF}{\mathcal{F}} \newcommand{\CG}{\mathcal{G}} \newcommand{\CH}{\mathcal{H}} \newcommand{\CI}{\mathcal{I}} \newcommand{\CJ}{\mathcal{J}} \newcommand{\CK}{\mathcal{K}} \newcommand{\CL}{\mathcal{L}} \newcommand{\CM}{\mathcal{M}} \newcommand{\CN}{\mathcal{N}} \newcommand{\CO}{\mathcal{O}} \newcommand{\CP}{\mathcal{P}} \newcommand{\CQ}{\mathcal{Q}} \newcommand{\CR}{\mathcal{R}} \newcommand{\CS}{\mathcal{S}} \newcommand{\CT}{\mathcal{T}} \newcommand{\CU}{\mathcal{U}} \newcommand{\CV}{\mathcal{V}} \newcommand{\CW}{\mathcal{W}} \newcommand{\CX}{\mathcal{X}} \newcommand{\CY}{\mathcal{Y}} \newcommand{\CZ}{\mathcal{Z}} \newcommand{\frA}{\mathfrak{A}} \newcommand{\frB}{\mathfrak{B}} \newcommand{\frC}{\mathfrak{C}} \newcommand{\frD}{\mathfrak{D}} \newcommand{\frE}{\mathfrak{E}} \newcommand{\frF}{\mathfrak{F}} \newcommand{\frG}{\mathfrak{G}} \newcommand{\frH}{\mathfrak{H}} \newcommand{\frI}{\mathfrak{I}} \newcommand{\frJ}{\mathfrak{J}} \newcommand{\frK}{\mathfrak{K}} \newcommand{\frL}{\mathfrak{L}} \newcommand{\frM}{\mathfrak{M}} \newcommand{\frN}{\mathfrak{N}} \newcommand{\frO}{\mathfrak{O}} \newcommand{\frP}{\mathfrak{P}} \newcommand{\frQ}{\mathfrak{Q}} \newcommand{\frR}{\mathfrak{R}} \newcommand{\frS}{\mathfrak{S}} \newcommand{\frT}{\mathfrak{T}} \newcommand{\frU}{\mathfrak{U}} \newcommand{\frV}{\mathfrak{V}} \newcommand{\frW}{\mathfrak{W}} \newcommand{\frX}{\mathfrak{X}} \newcommand{\frY}{\mathfrak{Y}} \newcommand{\frZ}{\mathfrak{Z}} \newcommand{\CNP}{\mathcal{NP}} \newcommand{\CPP}{\mathcal{PP}} \newcommand{\SP}{\mathsf{P}} \newcommand{\SPP}{\mathsf{PP}} \newcommand{\SSP}{\mathsf{\#P}} \newcommand{\SNP}{\mathsf{NP}} \newcommand{\SBPP}{\mathsf{BPP}} \newcommand{\ScoNP}{\mathsf{coNP}} \newcommand{\bbone}{\mathbbm{1}} \newcommand{\ord}{\mathrm{ord}} \newcommand{\odr}{\vee} \newcommand{\und}{\wedge} \newcommand{\Odr}{\bigvee} \newcommand{\Und}{\bigwedge} \newcommand{\xor}{\oplus} \newcommand{\Xor}{\bigoplus} \newcommand{\bmat}[1]{\begin{bmatrix} #1 \end{bmatrix}} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\argmax}{argmax}\]]]></summary></entry><entry><title type="html">Interactive Classification 4: Relative Strength of Cooperative and Adversarial Prover</title><link href="https://swaeldchen.github.io/blog/2023/FI_Relative_Strength/" rel="alternate" type="text/html" title="Interactive Classification 4: Relative Strength of Cooperative and Adversarial Prover"/><published>2023-01-04T00:00:00+01:00</published><updated>2023-01-04T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/FI_Relative_Strength</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/FI_Relative_Strength/"><![CDATA[\[\newcommand{\kl}[1]{\mathopen{}\left( #1 \right)\mathclose{}} \newcommand{\ekl}[1]{\mathopen{}\left[ #1 \right]\mathclose{}} \newcommand{\skl}[1]{\mathopen{}\left\{ #1 \right\}\mathclose{}} \newcommand{\bkl}[1]{\mathopen{}\left| #1 \right|\mathclose{}} \newcommand{\nkl}[1]{\mathopen{}\left\| #1 \right\|\mathclose{}} \newcommand{\bfa}{\mathbf{a}} \newcommand{\bfb}{\mathbf{b}} \newcommand{\bfc}{\mathbf{c}} \newcommand{\bfd}{\mathbf{d}} \newcommand{\bfe}{\mathbf{e}} \newcommand{\bff}{\mathbf{f}} \newcommand{\bfg}{\mathbf{g}} \newcommand{\bfh}{\mathbf{h}} \newcommand{\bfi}{\mathbf{i}} \newcommand{\bfj}{\mathbf{j}} \newcommand{\bfk}{\mathbf{k}} \newcommand{\bfl}{\mathbf{l}} \newcommand{\bfm}{\mathbf{m}} \newcommand{\bfn}{\mathbf{n}} \newcommand{\bfo}{\mathbf{o}} \newcommand{\bfp}{\mathbf{p}} \newcommand{\bfq}{\mathbf{q}} \newcommand{\bfr}{\mathbf{r}} \newcommand{\bfs}{\mathbf{s}} \newcommand{\bft}{\mathbf{t}} \newcommand{\bfu}{\mathbf{u}} \newcommand{\bfv}{\mathbf{v}} \newcommand{\bfw}{\mathbf{w}} \newcommand{\bfx}{\mathbf{x}} \newcommand{\bfy}{\mathbf{y}} \newcommand{\bfz}{\mathbf{z}} \newcommand{\bfA}{\mathbf{A}} \newcommand{\bfB}{\mathbf{B}} \newcommand{\bfC}{\mathbf{C}} \newcommand{\bfD}{\mathbf{D}} \newcommand{\bfE}{\mathbf{E}} \newcommand{\bfF}{\mathbf{F}} \newcommand{\bfG}{\mathbf{G}} \newcommand{\bfH}{\mathbf{H}} \newcommand{\bfI}{\mathbf{I}} \newcommand{\bfJ}{\mathbf{J}} \newcommand{\bfK}{\mathbf{K}} \newcommand{\bfL}{\mathbf{L}} \newcommand{\bfM}{\mathbf{M}} \newcommand{\bfN}{\mathbf{N}} \newcommand{\bfO}{\mathbf{O}} \newcommand{\bfP}{\mathbf{P}} \newcommand{\bfQ}{\mathbf{Q}} \newcommand{\bfR}{\mathbf{R}} \newcommand{\bfS}{\mathbf{S}} \newcommand{\bfT}{\mathbf{T}} \newcommand{\bfU}{\mathbf{U}} \newcommand{\bfV}{\mathbf{V}} \newcommand{\bfW}{\mathbf{W}} \newcommand{\bfX}{\mathbf{X}} \newcommand{\bfY}{\mathbf{Y}} \newcommand{\bfZ}{\mathbf{Z}} \newcommand{\bfone}{\mathbf{1}} \newcommand{\bfzero}{\mathbf{0}} \newcommand{\E}{\mathbb{E}} \newcommand{\R}{\mathbb{R}} \renewcommand{\P}{\mathbb{P}} \newcommand{\bfmu}{\bm{\mu}} \newcommand{\bfsigma}{\bm{\sigma}} \newcommand{\bfdelta}{\boldsymbol{\delta}} \newcommand{\bfSigma}{\bm{\Sigma}} \newcommand{\bfLambda}{\bm{\Lambda}} \newcommand{\bfeta}{\bm{\eta}} \newcommand{\bftheta}{\bm{\theta}} \newcommand{\CA}{\mathcal{A}} \newcommand{\CB}{\mathcal{B}} \newcommand{\CC}{\mathcal{C}} \newcommand{\CD}{\mathcal{D}} \newcommand{\CE}{\mathcal{E}} \newcommand{\CF}{\mathcal{F}} \newcommand{\CG}{\mathcal{G}} \newcommand{\CH}{\mathcal{H}} \newcommand{\CI}{\mathcal{I}} \newcommand{\CJ}{\mathcal{J}} \newcommand{\CK}{\mathcal{K}} \newcommand{\CL}{\mathcal{L}} \newcommand{\CM}{\mathcal{M}} \newcommand{\CN}{\mathcal{N}} \newcommand{\CO}{\mathcal{O}} \newcommand{\CP}{\mathcal{P}} \newcommand{\CQ}{\mathcal{Q}} \newcommand{\CR}{\mathcal{R}} \newcommand{\CS}{\mathcal{S}} \newcommand{\CT}{\mathcal{T}} \newcommand{\CU}{\mathcal{U}} \newcommand{\CV}{\mathcal{V}} \newcommand{\CW}{\mathcal{W}} \newcommand{\CX}{\mathcal{X}} \newcommand{\CY}{\mathcal{Y}} \newcommand{\CZ}{\mathcal{Z}} \newcommand{\frA}{\mathfrak{A}} \newcommand{\frB}{\mathfrak{B}} \newcommand{\frC}{\mathfrak{C}} \newcommand{\frD}{\mathfrak{D}} \newcommand{\frE}{\mathfrak{E}} \newcommand{\frF}{\mathfrak{F}} \newcommand{\frG}{\mathfrak{G}} \newcommand{\frH}{\mathfrak{H}} \newcommand{\frI}{\mathfrak{I}} \newcommand{\frJ}{\mathfrak{J}} \newcommand{\frK}{\mathfrak{K}} \newcommand{\frL}{\mathfrak{L}} \newcommand{\frM}{\mathfrak{M}} \newcommand{\frN}{\mathfrak{N}} \newcommand{\frO}{\mathfrak{O}} \newcommand{\frP}{\mathfrak{P}} \newcommand{\frQ}{\mathfrak{Q}} \newcommand{\frR}{\mathfrak{R}} \newcommand{\frS}{\mathfrak{S}} \newcommand{\frT}{\mathfrak{T}} \newcommand{\frU}{\mathfrak{U}} \newcommand{\frV}{\mathfrak{V}} \newcommand{\frW}{\mathfrak{W}} \newcommand{\frX}{\mathfrak{X}} \newcommand{\frY}{\mathfrak{Y}} \newcommand{\frZ}{\mathfrak{Z}} \newcommand{\CNP}{\mathcal{NP}} \newcommand{\CPP}{\mathcal{PP}} \newcommand{\SP}{\mathsf{P}} \newcommand{\SPP}{\mathsf{PP}} \newcommand{\SSP}{\mathsf{\#P}} \newcommand{\SNP}{\mathsf{NP}} \newcommand{\SBPP}{\mathsf{BPP}} \newcommand{\ScoNP}{\mathsf{coNP}} \newcommand{\bbone}{\mathbbm{1}} \newcommand{\ord}{\mathrm{ord}} \newcommand{\odr}{\vee} \newcommand{\und}{\wedge} \newcommand{\Odr}{\bigvee} \newcommand{\Und}{\bigwedge} \newcommand{\xor}{\oplus} \newcommand{\Xor}{\bigoplus} \newcommand{\bmat}[1]{\begin{bmatrix} #1 \end{bmatrix}} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\argmax}{argmax}\] <p>$\newcommand{\ap}{\text{Pr}}$ $\newcommand{\morg}{\widehat{M}}$</p> <style>.figcap{font-size:.9em}</style> <p>This post is part 4 of my series on <a href="/blog/2023/FI_start/">Interactive Classification</a>.</p> <p>*TL;DR: It’s not necessary that Morgana plays perfectly to counter Merlin, only that she is able to find similar features with a comparable success rate. We go over</p> <ol> <li>Definition of relative strength</li> <li>Potential computational barriers for Morgana</li> <li>Resultig theorem</li> </ol> <h3 id="relative-strength-of-merlin-and-morgana">Relative Strength of Merlin and Morgana</h3> <p>Another important metric that we care about is the relative strength of the Merlin and Morgana classifiers. This is especially important if we intend to apply our setup to real data sets where Merlin and Morgana are not able to find the optimal features are every step. We can relax thsi requirement in two important ways:</p> <ol> <li>She only needs to find the same features that Merlin also uses</li> <li>She only needs to do so at a success rate similar to Merlin</li> </ol> <p>With this in mind, we define the notion of relative success rate as follows.</p> <p><strong>Relative Success Rate:</strong> Let $A\in \CA$ and $M, \morg \in \CM(D)$. Then the relative success rate $\alpha$ is defined as</p> \[\alpha := \min_{l\in \{-1,1\}} \frac{\P_{\bfx\sim \CD_{-l}}\ekl{A(\morg(\bfx))=l \,|\, \bfx \in F_l^\ast}}{\P_{\bfx\sim \CD_{l}}\ekl{A(M(\bfx))=l \,|\, \bfx \in F_l^\ast}},\] <p>where \(F_{l} := \{\phi \in \Sigma \,|\, \bfz\in M(D_l), A(\bfz)=l\}\) is the set that Merlin uses to successfully convince Arthur of class $l$. In plain words: Given that the the datapoint has a feature that Merlin could successfully use, how likely is Morgana to discover this feature relative to Merlin?</p> <p>It stands to reason that if both provers are implemented by the same algorithm, their performance should be similar. Of course, as with anything neural network related that might be hard to prove in practice. In <strong>Figure 1</strong> we present an example of an exponentially bad relative strength for a as long as Morgana is implemented with a polynomial-time algorithm.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/random_sparse.svg" alt="img1" style="float:center; width:80%"/> <p style="clear: both;"></p> </div> <p class="figcap"><br/> <strong>Figure 1.</strong> Illustration of a dataset where Morgana’s task is computationally harder than the one of Merlin and we should expect a very low relative strength. Class $-1$ consists of $k$-sparse images whose pixel values sum to some number $S$. For each of these images, there is a non-sparse image in class $1$ that shares all non-zero values (marked in red for the first image). Merlin can use the strategy to show all $k$ non-zero pixels for an image from class $-1$ and $k+1$ arbitrary non-zero pixels for class $1$. Arthur checks if the sum is equal to $S$ or if the number of pixels equal to $k+1$, otherwise he says “Don’t know!”. He will then classify with 100\% accuracy. Nevertheless, the features Merlin uses for class $-1$ are completely uncorrelated with the class label. To exploit this, however, Morgana would have to solve the $\SNP$-hard (see <a class="citation" href="#kleinberg2006algorithm">(Kleinberg &amp; Tardos, 2006)</a>) subset sum problem to find the pixels for images in class 1 that sum to $S$. The question is not in which class we can find the features, but in which class we can find the features <em>efficiently</em>.</p> <p><br/></p> <h3 id="key-result">Key Result</h3> <p>With the notions of Relative Strength and Asymmetric Feature Correlation in mind, we can provide a key theoretical result.</p> <p><strong>Main Theorem:</strong> Let $D$ be two-class data space with AFC of $\kappa$ and class imbalance $B$. Let $A\in \CA$, and $M, \widehat{M}\in\CM(D)$ such that $\widehat{M}$ has a relative success rate of $\alpha$ with respect to $A, M$ and $D$. Define</p> <ol> <li>Completeness: \(\min\limits_{l \in \{-1,1\}}\P_{\bfx \sim \CD_l}\ekl{A(M(\bfx)) = c(\bfx) } \geq 1- \epsilon_c,\)</li> <li>Soundness \(\max\limits_{l \in \{-1,1\}} \P_{\bfx \sim \CD_l}\ekl{A(\morg(\bfx)) = -c(\bfx) } \leq \epsilon_s.\)</li> </ol> <p>where $\CD_l$ is the data distribution conditioned on the class $l$. Then it follows that</p> \[\ap_{\CD}(M) \geq 1 - \epsilon_c - \frac{ \kappa \alpha^{-1}\epsilon_s}{1 - \epsilon_c+ \kappa \alpha^{-1}B^{-1}\epsilon_s}.\] <p>This result shows that we can bound the performance of the feature selector Merlin (in terms of average precision) in the Merlin-Arthur framework using measurable metrics such as completeness and soundness.</p> <h3 id="key-takeaways">Key Takeaways</h3> <p>The above theoretical discussion shows two key contributions of our framework.</p> <ol> <li> <p>We do not assume our agents to be optimal, but rather that Morgana has a comparable success rate to Merlin. This seems reasonable when we use the same algorithms for both and deal with real-world datasets.</p> </li> <li> <p>We can use the relative strength and the AFC to derive a lower bound on the precision of the features that are selected by Merlin.</p> </li> </ol> <p><a href="/blog/2023/FI_AFC/">◀ Previous Post</a></p> <p align="right"><a href="/blog/2023/FI_Complexity/" align="right"> Next Post &#9654;</a></p> <h3 id="references">References</h3> <ol class="bibliography"><li><div class="text-justify"> <span id="kleinberg2006algorithm">Kleinberg, J., &amp; Tardos, E. (2006). <i>Algorithm design</i>. Pearson Education India.</span> </div> <div> </div> <div> </div> </li></ol>]]></content><author><name>Stephan Wäldchen</name></author><category term="research"/><category term="optimization"/><category term="ml"/><category term="uniform convexity"/><category term="abstract"/><summary type="html"><![CDATA[\[\newcommand{\kl}[1]{\mathopen{}\left( #1 \right)\mathclose{}} \newcommand{\ekl}[1]{\mathopen{}\left[ #1 \right]\mathclose{}} \newcommand{\skl}[1]{\mathopen{}\left\{ #1 \right\}\mathclose{}} \newcommand{\bkl}[1]{\mathopen{}\left| #1 \right|\mathclose{}} \newcommand{\nkl}[1]{\mathopen{}\left\| #1 \right\|\mathclose{}} \newcommand{\bfa}{\mathbf{a}} \newcommand{\bfb}{\mathbf{b}} \newcommand{\bfc}{\mathbf{c}} \newcommand{\bfd}{\mathbf{d}} \newcommand{\bfe}{\mathbf{e}} \newcommand{\bff}{\mathbf{f}} \newcommand{\bfg}{\mathbf{g}} \newcommand{\bfh}{\mathbf{h}} \newcommand{\bfi}{\mathbf{i}} \newcommand{\bfj}{\mathbf{j}} \newcommand{\bfk}{\mathbf{k}} \newcommand{\bfl}{\mathbf{l}} \newcommand{\bfm}{\mathbf{m}} \newcommand{\bfn}{\mathbf{n}} \newcommand{\bfo}{\mathbf{o}} \newcommand{\bfp}{\mathbf{p}} \newcommand{\bfq}{\mathbf{q}} \newcommand{\bfr}{\mathbf{r}} \newcommand{\bfs}{\mathbf{s}} \newcommand{\bft}{\mathbf{t}} \newcommand{\bfu}{\mathbf{u}} \newcommand{\bfv}{\mathbf{v}} \newcommand{\bfw}{\mathbf{w}} \newcommand{\bfx}{\mathbf{x}} \newcommand{\bfy}{\mathbf{y}} \newcommand{\bfz}{\mathbf{z}} \newcommand{\bfA}{\mathbf{A}} \newcommand{\bfB}{\mathbf{B}} \newcommand{\bfC}{\mathbf{C}} \newcommand{\bfD}{\mathbf{D}} \newcommand{\bfE}{\mathbf{E}} \newcommand{\bfF}{\mathbf{F}} \newcommand{\bfG}{\mathbf{G}} \newcommand{\bfH}{\mathbf{H}} \newcommand{\bfI}{\mathbf{I}} \newcommand{\bfJ}{\mathbf{J}} \newcommand{\bfK}{\mathbf{K}} \newcommand{\bfL}{\mathbf{L}} \newcommand{\bfM}{\mathbf{M}} \newcommand{\bfN}{\mathbf{N}} \newcommand{\bfO}{\mathbf{O}} \newcommand{\bfP}{\mathbf{P}} \newcommand{\bfQ}{\mathbf{Q}} \newcommand{\bfR}{\mathbf{R}} \newcommand{\bfS}{\mathbf{S}} \newcommand{\bfT}{\mathbf{T}} \newcommand{\bfU}{\mathbf{U}} \newcommand{\bfV}{\mathbf{V}} \newcommand{\bfW}{\mathbf{W}} \newcommand{\bfX}{\mathbf{X}} \newcommand{\bfY}{\mathbf{Y}} \newcommand{\bfZ}{\mathbf{Z}} \newcommand{\bfone}{\mathbf{1}} \newcommand{\bfzero}{\mathbf{0}} \newcommand{\E}{\mathbb{E}} \newcommand{\R}{\mathbb{R}} \renewcommand{\P}{\mathbb{P}} \newcommand{\bfmu}{\bm{\mu}} \newcommand{\bfsigma}{\bm{\sigma}} \newcommand{\bfdelta}{\boldsymbol{\delta}} \newcommand{\bfSigma}{\bm{\Sigma}} \newcommand{\bfLambda}{\bm{\Lambda}} \newcommand{\bfeta}{\bm{\eta}} \newcommand{\bftheta}{\bm{\theta}} \newcommand{\CA}{\mathcal{A}} \newcommand{\CB}{\mathcal{B}} \newcommand{\CC}{\mathcal{C}} \newcommand{\CD}{\mathcal{D}} \newcommand{\CE}{\mathcal{E}} \newcommand{\CF}{\mathcal{F}} \newcommand{\CG}{\mathcal{G}} \newcommand{\CH}{\mathcal{H}} \newcommand{\CI}{\mathcal{I}} \newcommand{\CJ}{\mathcal{J}} \newcommand{\CK}{\mathcal{K}} \newcommand{\CL}{\mathcal{L}} \newcommand{\CM}{\mathcal{M}} \newcommand{\CN}{\mathcal{N}} \newcommand{\CO}{\mathcal{O}} \newcommand{\CP}{\mathcal{P}} \newcommand{\CQ}{\mathcal{Q}} \newcommand{\CR}{\mathcal{R}} \newcommand{\CS}{\mathcal{S}} \newcommand{\CT}{\mathcal{T}} \newcommand{\CU}{\mathcal{U}} \newcommand{\CV}{\mathcal{V}} \newcommand{\CW}{\mathcal{W}} \newcommand{\CX}{\mathcal{X}} \newcommand{\CY}{\mathcal{Y}} \newcommand{\CZ}{\mathcal{Z}} \newcommand{\frA}{\mathfrak{A}} \newcommand{\frB}{\mathfrak{B}} \newcommand{\frC}{\mathfrak{C}} \newcommand{\frD}{\mathfrak{D}} \newcommand{\frE}{\mathfrak{E}} \newcommand{\frF}{\mathfrak{F}} \newcommand{\frG}{\mathfrak{G}} \newcommand{\frH}{\mathfrak{H}} \newcommand{\frI}{\mathfrak{I}} \newcommand{\frJ}{\mathfrak{J}} \newcommand{\frK}{\mathfrak{K}} \newcommand{\frL}{\mathfrak{L}} \newcommand{\frM}{\mathfrak{M}} \newcommand{\frN}{\mathfrak{N}} \newcommand{\frO}{\mathfrak{O}} \newcommand{\frP}{\mathfrak{P}} \newcommand{\frQ}{\mathfrak{Q}} \newcommand{\frR}{\mathfrak{R}} \newcommand{\frS}{\mathfrak{S}} \newcommand{\frT}{\mathfrak{T}} \newcommand{\frU}{\mathfrak{U}} \newcommand{\frV}{\mathfrak{V}} \newcommand{\frW}{\mathfrak{W}} \newcommand{\frX}{\mathfrak{X}} \newcommand{\frY}{\mathfrak{Y}} \newcommand{\frZ}{\mathfrak{Z}} \newcommand{\CNP}{\mathcal{NP}} \newcommand{\CPP}{\mathcal{PP}} \newcommand{\SP}{\mathsf{P}} \newcommand{\SPP}{\mathsf{PP}} \newcommand{\SSP}{\mathsf{\#P}} \newcommand{\SNP}{\mathsf{NP}} \newcommand{\SBPP}{\mathsf{BPP}} \newcommand{\ScoNP}{\mathsf{coNP}} \newcommand{\bbone}{\mathbbm{1}} \newcommand{\ord}{\mathrm{ord}} \newcommand{\odr}{\vee} \newcommand{\und}{\wedge} \newcommand{\Odr}{\bigvee} \newcommand{\Und}{\bigwedge} \newcommand{\xor}{\oplus} \newcommand{\Xor}{\bigoplus} \newcommand{\bmat}[1]{\begin{bmatrix} #1 \end{bmatrix}} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\argmax}{argmax}\]]]></summary></entry><entry><title type="html">Interactive Classification 5: Computational Complexity</title><link href="https://swaeldchen.github.io/blog/2023/FI_Complexity/" rel="alternate" type="text/html" title="Interactive Classification 5: Computational Complexity"/><published>2023-01-03T00:00:00+01:00</published><updated>2023-01-03T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/FI_Complexity</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/FI_Complexity/"><![CDATA[\[\newcommand{\kl}[1]{\mathopen{}\left( #1 \right)\mathclose{}} \newcommand{\ekl}[1]{\mathopen{}\left[ #1 \right]\mathclose{}} \newcommand{\skl}[1]{\mathopen{}\left\{ #1 \right\}\mathclose{}} \newcommand{\bkl}[1]{\mathopen{}\left| #1 \right|\mathclose{}} \newcommand{\nkl}[1]{\mathopen{}\left\| #1 \right\|\mathclose{}} \newcommand{\bfa}{\mathbf{a}} \newcommand{\bfb}{\mathbf{b}} \newcommand{\bfc}{\mathbf{c}} \newcommand{\bfd}{\mathbf{d}} \newcommand{\bfe}{\mathbf{e}} \newcommand{\bff}{\mathbf{f}} \newcommand{\bfg}{\mathbf{g}} \newcommand{\bfh}{\mathbf{h}} \newcommand{\bfi}{\mathbf{i}} \newcommand{\bfj}{\mathbf{j}} \newcommand{\bfk}{\mathbf{k}} \newcommand{\bfl}{\mathbf{l}} \newcommand{\bfm}{\mathbf{m}} \newcommand{\bfn}{\mathbf{n}} \newcommand{\bfo}{\mathbf{o}} \newcommand{\bfp}{\mathbf{p}} \newcommand{\bfq}{\mathbf{q}} \newcommand{\bfr}{\mathbf{r}} \newcommand{\bfs}{\mathbf{s}} \newcommand{\bft}{\mathbf{t}} \newcommand{\bfu}{\mathbf{u}} \newcommand{\bfv}{\mathbf{v}} \newcommand{\bfw}{\mathbf{w}} \newcommand{\bfx}{\mathbf{x}} \newcommand{\bfy}{\mathbf{y}} \newcommand{\bfz}{\mathbf{z}} \newcommand{\bfA}{\mathbf{A}} \newcommand{\bfB}{\mathbf{B}} \newcommand{\bfC}{\mathbf{C}} \newcommand{\bfD}{\mathbf{D}} \newcommand{\bfE}{\mathbf{E}} \newcommand{\bfF}{\mathbf{F}} \newcommand{\bfG}{\mathbf{G}} \newcommand{\bfH}{\mathbf{H}} \newcommand{\bfI}{\mathbf{I}} \newcommand{\bfJ}{\mathbf{J}} \newcommand{\bfK}{\mathbf{K}} \newcommand{\bfL}{\mathbf{L}} \newcommand{\bfM}{\mathbf{M}} \newcommand{\bfN}{\mathbf{N}} \newcommand{\bfO}{\mathbf{O}} \newcommand{\bfP}{\mathbf{P}} \newcommand{\bfQ}{\mathbf{Q}} \newcommand{\bfR}{\mathbf{R}} \newcommand{\bfS}{\mathbf{S}} \newcommand{\bfT}{\mathbf{T}} \newcommand{\bfU}{\mathbf{U}} \newcommand{\bfV}{\mathbf{V}} \newcommand{\bfW}{\mathbf{W}} \newcommand{\bfX}{\mathbf{X}} \newcommand{\bfY}{\mathbf{Y}} \newcommand{\bfZ}{\mathbf{Z}} \newcommand{\bfone}{\mathbf{1}} \newcommand{\bfzero}{\mathbf{0}} \newcommand{\E}{\mathbb{E}} \newcommand{\R}{\mathbb{R}} \renewcommand{\P}{\mathbb{P}} \newcommand{\bfmu}{\bm{\mu}} \newcommand{\bfsigma}{\bm{\sigma}} \newcommand{\bfdelta}{\boldsymbol{\delta}} \newcommand{\bfSigma}{\bm{\Sigma}} \newcommand{\bfLambda}{\bm{\Lambda}} \newcommand{\bfeta}{\bm{\eta}} \newcommand{\bftheta}{\bm{\theta}} \newcommand{\CA}{\mathcal{A}} \newcommand{\CB}{\mathcal{B}} \newcommand{\CC}{\mathcal{C}} \newcommand{\CD}{\mathcal{D}} \newcommand{\CE}{\mathcal{E}} \newcommand{\CF}{\mathcal{F}} \newcommand{\CG}{\mathcal{G}} \newcommand{\CH}{\mathcal{H}} \newcommand{\CI}{\mathcal{I}} \newcommand{\CJ}{\mathcal{J}} \newcommand{\CK}{\mathcal{K}} \newcommand{\CL}{\mathcal{L}} \newcommand{\CM}{\mathcal{M}} \newcommand{\CN}{\mathcal{N}} \newcommand{\CO}{\mathcal{O}} \newcommand{\CP}{\mathcal{P}} \newcommand{\CQ}{\mathcal{Q}} \newcommand{\CR}{\mathcal{R}} \newcommand{\CS}{\mathcal{S}} \newcommand{\CT}{\mathcal{T}} \newcommand{\CU}{\mathcal{U}} \newcommand{\CV}{\mathcal{V}} \newcommand{\CW}{\mathcal{W}} \newcommand{\CX}{\mathcal{X}} \newcommand{\CY}{\mathcal{Y}} \newcommand{\CZ}{\mathcal{Z}} \newcommand{\frA}{\mathfrak{A}} \newcommand{\frB}{\mathfrak{B}} \newcommand{\frC}{\mathfrak{C}} \newcommand{\frD}{\mathfrak{D}} \newcommand{\frE}{\mathfrak{E}} \newcommand{\frF}{\mathfrak{F}} \newcommand{\frG}{\mathfrak{G}} \newcommand{\frH}{\mathfrak{H}} \newcommand{\frI}{\mathfrak{I}} \newcommand{\frJ}{\mathfrak{J}} \newcommand{\frK}{\mathfrak{K}} \newcommand{\frL}{\mathfrak{L}} \newcommand{\frM}{\mathfrak{M}} \newcommand{\frN}{\mathfrak{N}} \newcommand{\frO}{\mathfrak{O}} \newcommand{\frP}{\mathfrak{P}} \newcommand{\frQ}{\mathfrak{Q}} \newcommand{\frR}{\mathfrak{R}} \newcommand{\frS}{\mathfrak{S}} \newcommand{\frT}{\mathfrak{T}} \newcommand{\frU}{\mathfrak{U}} \newcommand{\frV}{\mathfrak{V}} \newcommand{\frW}{\mathfrak{W}} \newcommand{\frX}{\mathfrak{X}} \newcommand{\frY}{\mathfrak{Y}} \newcommand{\frZ}{\mathfrak{Z}} \newcommand{\CNP}{\mathcal{NP}} \newcommand{\CPP}{\mathcal{PP}} \newcommand{\SP}{\mathsf{P}} \newcommand{\SPP}{\mathsf{PP}} \newcommand{\SSP}{\mathsf{\#P}} \newcommand{\SNP}{\mathsf{NP}} \newcommand{\SBPP}{\mathsf{BPP}} \newcommand{\ScoNP}{\mathsf{coNP}} \newcommand{\bbone}{\mathbbm{1}} \newcommand{\ord}{\mathrm{ord}} \newcommand{\odr}{\vee} \newcommand{\und}{\wedge} \newcommand{\Odr}{\bigvee} \newcommand{\Und}{\bigwedge} \newcommand{\xor}{\oplus} \newcommand{\Xor}{\bigoplus} \newcommand{\bmat}[1]{\begin{bmatrix} #1 \end{bmatrix}} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\argmax}{argmax}\] <p>This post is part 5 of my series on <a href="/blog/2023/FI_start/">Interactive Classification</a></p> <p>*TL;DR: We explain the computational complexity of interpreting neural network classifier.</p> <ol> <li>Finding small precise features is a hard task even if done only approximately.</li> <li>We can use heuristics as long as we can verify that the heuristic has succeeded a posteriori.</li> <li>To audit a Merlin-Arthur classifier the auditor needs comparable computational resources as the designer of the classifier.</li> </ol> <h2 id="computational-complexity-of-finding-features-with-high-precision">Computational Complexity of finding features with High precision</h2> <p>On its face, it is not surprising that finding small features that have high precision is an NP-hard task, since it implies combinatorial search over sets of input variables.</p> <p>We have shown this explicitely in <a class="citation" href="#waldchen2021computational">(Wäldchen et al., 2021)</a>. That paper still uses the term $\delta$-relevant features, which is equivalent to a feature with a precision of $\delta$. We also show the stronger result that the smallest set of features with precision $\delta$ cannot be approximated better than $d^{1-\alpha}$ unless $\SP=\SNP$, where $d$ is the input dimension and $\alpha&gt;0$. Note that for $\alpha=0$ we get the trivial approximation of simply taking that whole input as feature with perfect precision. This means that one cannot prove for any procedure that it systematically finds small precise features should they exist. This holds even for two-layer neural networks.</p> <p>Instead of selecting the smalles set (cardinality-minimal), one can relax the question to selecting a set that cannot be made smaller by omitting any elements from it (inclusion-minimal). For monotone classificers, this makes the problem straight-forward to solve, as shown in <a class="citation" href="#shih2018symbolic">(Shih et al., 2018)</a>, as one can simply successively omit input variables from a feature until any further omission would reduce the precision below $\delta$. The authors additionally show that this is efficiently possible for classifiers represented as <a href="https://en.wikipedia.org/wiki/Binary_decision_diagram">Ordered Binary Decision Diagrams (OBDDs)</a>.</p> <h2 id="the-result-by-blanc-et-al">The Result by Blanc et al.</h2> <p>While we have shown that there are networks and inputs for which finding small precise features is a hard task, a surprising result by <a class="citation" href="#blanc2021provably">(Blanc et al., 2021)</a> shows for a random input it is feasible in polynomial time with high probability. The caveat here is the size of the found feature, which is polynomial in the size of the smallest precise feature. In fact, it grows so quickly that is unusuable in practice if there does not exist a precise feature that is orders of magnitude smaller than the whole input dimension. Nevertheless, this is an impressive result connecting interesting topics, such as stabiliser trees, implicit representation etc.</p> <h2 id="how-to-overcome-computational-barrier">How to overcome computational barrier?</h2> <p>The computational complexity can be ignored. Instead, we can use a heuristic method to select a feature and confirm high precision afterwards. The Merlin-Arthur framework is a heuristic as well in this regard, as we are not guaranteed to converge to a setup with high completeness and soundness, but we can easily check whether this has been achieved.</p> <p>This is similar to the training process of neural networks. Designing a classifier with high accuracy is a computationally hard task. But SGD is a method that reliably succeeds in practice, and one can confirm success via the test set evaluation. Completness and soundness thus take the role of the test accuracy and confirm not only good performance bu also interpretability.</p> <h2 id="use-of-arthur-merlin-classifiers-as-explainable-classifiers">Use of Arthur-Merlin Classifiers as Explainable classifiers</h2> <p>Let us come back to the main reason we introduce the Merlin-Arthur classifier for formal interpretability. We want a setup that is provably explainable, especially for the case when the designer of the classifier wants to hide the true reasoning of the classifier. This is important for commercial classifiers, e.g. for hiring decicions. An auditor would want to check if the reason a candidate was hired or rejected was not based on protected features like gender or race.</p> <p>We have seen proved that if a sound and complete Merlin-Arthur classifiers has to exchange informative features. An auditor could confirm the soundness with their own Morgana, as to make sure that the setup is actually sound.</p> <p>In our theorems we have seen that the precision bound depends on the relative success rate of Merlin and Morgana. This means that this scheme is successful as long as the company designing the classifier and the auditor have comparable computational resources. This again reflected in the AFC, since we have shown that determining the size of the AFC is as hard as exploiting it. This again reflects that the certification of the Merlin-Arthur classifier works as long as the auditor has comparable computational resources as the firm they are auditing. On the other hand, the auditor does not need to model the datamanifold that the classifier operates on. This task is potentially much harder and has to be done for every new classification task, compared with just designing a good search routine for Morgana.</p> <p><a href="/blog/2023/FI_Relative_Strength/">◀ Previous Post</a></p> <h3 id="references">References</h3> <ol class="bibliography"><li><div class="text-justify"> <span id="waldchen2021computational">Wäldchen, S., Macdonald, J., Hauch, S., &amp; Kutyniok, G. (2021). The computational complexity of understanding binary classifier decisions. <i>Journal of Artificial Intelligence Research</i>, <i>70</i>, 351–387.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="shih2018symbolic">Shih, A., Choi, A., &amp; Darwiche, A. (2018). A symbolic approach to explaining bayesian network classifiers. <i>ArXiv Preprint ArXiv:1805.03364</i>.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="blanc2021provably">Blanc, G., Lange, J., &amp; Tan, L.-Y. (2021). Provably efficient, succinct, and precise explanations. <i>Advances in Neural Information Processing Systems</i>, <i>34</i>, 6129–6141.</span> </div> <div> </div> <div> </div> </li></ol>]]></content><author><name>Stephan Wäldchen</name></author><category term="research"/><category term="optimization"/><category term="ml"/><category term="uniform convexity"/><category term="abstract"/><summary type="html"><![CDATA[\[\newcommand{\kl}[1]{\mathopen{}\left( #1 \right)\mathclose{}} \newcommand{\ekl}[1]{\mathopen{}\left[ #1 \right]\mathclose{}} \newcommand{\skl}[1]{\mathopen{}\left\{ #1 \right\}\mathclose{}} \newcommand{\bkl}[1]{\mathopen{}\left| #1 \right|\mathclose{}} \newcommand{\nkl}[1]{\mathopen{}\left\| #1 \right\|\mathclose{}} \newcommand{\bfa}{\mathbf{a}} \newcommand{\bfb}{\mathbf{b}} \newcommand{\bfc}{\mathbf{c}} \newcommand{\bfd}{\mathbf{d}} \newcommand{\bfe}{\mathbf{e}} \newcommand{\bff}{\mathbf{f}} \newcommand{\bfg}{\mathbf{g}} \newcommand{\bfh}{\mathbf{h}} \newcommand{\bfi}{\mathbf{i}} \newcommand{\bfj}{\mathbf{j}} \newcommand{\bfk}{\mathbf{k}} \newcommand{\bfl}{\mathbf{l}} \newcommand{\bfm}{\mathbf{m}} \newcommand{\bfn}{\mathbf{n}} \newcommand{\bfo}{\mathbf{o}} \newcommand{\bfp}{\mathbf{p}} \newcommand{\bfq}{\mathbf{q}} \newcommand{\bfr}{\mathbf{r}} \newcommand{\bfs}{\mathbf{s}} \newcommand{\bft}{\mathbf{t}} \newcommand{\bfu}{\mathbf{u}} \newcommand{\bfv}{\mathbf{v}} \newcommand{\bfw}{\mathbf{w}} \newcommand{\bfx}{\mathbf{x}} \newcommand{\bfy}{\mathbf{y}} \newcommand{\bfz}{\mathbf{z}} \newcommand{\bfA}{\mathbf{A}} \newcommand{\bfB}{\mathbf{B}} \newcommand{\bfC}{\mathbf{C}} \newcommand{\bfD}{\mathbf{D}} \newcommand{\bfE}{\mathbf{E}} \newcommand{\bfF}{\mathbf{F}} \newcommand{\bfG}{\mathbf{G}} \newcommand{\bfH}{\mathbf{H}} \newcommand{\bfI}{\mathbf{I}} \newcommand{\bfJ}{\mathbf{J}} \newcommand{\bfK}{\mathbf{K}} \newcommand{\bfL}{\mathbf{L}} \newcommand{\bfM}{\mathbf{M}} \newcommand{\bfN}{\mathbf{N}} \newcommand{\bfO}{\mathbf{O}} \newcommand{\bfP}{\mathbf{P}} \newcommand{\bfQ}{\mathbf{Q}} \newcommand{\bfR}{\mathbf{R}} \newcommand{\bfS}{\mathbf{S}} \newcommand{\bfT}{\mathbf{T}} \newcommand{\bfU}{\mathbf{U}} \newcommand{\bfV}{\mathbf{V}} \newcommand{\bfW}{\mathbf{W}} \newcommand{\bfX}{\mathbf{X}} \newcommand{\bfY}{\mathbf{Y}} \newcommand{\bfZ}{\mathbf{Z}} \newcommand{\bfone}{\mathbf{1}} \newcommand{\bfzero}{\mathbf{0}} \newcommand{\E}{\mathbb{E}} \newcommand{\R}{\mathbb{R}} \renewcommand{\P}{\mathbb{P}} \newcommand{\bfmu}{\bm{\mu}} \newcommand{\bfsigma}{\bm{\sigma}} \newcommand{\bfdelta}{\boldsymbol{\delta}} \newcommand{\bfSigma}{\bm{\Sigma}} \newcommand{\bfLambda}{\bm{\Lambda}} \newcommand{\bfeta}{\bm{\eta}} \newcommand{\bftheta}{\bm{\theta}} \newcommand{\CA}{\mathcal{A}} \newcommand{\CB}{\mathcal{B}} \newcommand{\CC}{\mathcal{C}} \newcommand{\CD}{\mathcal{D}} \newcommand{\CE}{\mathcal{E}} \newcommand{\CF}{\mathcal{F}} \newcommand{\CG}{\mathcal{G}} \newcommand{\CH}{\mathcal{H}} \newcommand{\CI}{\mathcal{I}} \newcommand{\CJ}{\mathcal{J}} \newcommand{\CK}{\mathcal{K}} \newcommand{\CL}{\mathcal{L}} \newcommand{\CM}{\mathcal{M}} \newcommand{\CN}{\mathcal{N}} \newcommand{\CO}{\mathcal{O}} \newcommand{\CP}{\mathcal{P}} \newcommand{\CQ}{\mathcal{Q}} \newcommand{\CR}{\mathcal{R}} \newcommand{\CS}{\mathcal{S}} \newcommand{\CT}{\mathcal{T}} \newcommand{\CU}{\mathcal{U}} \newcommand{\CV}{\mathcal{V}} \newcommand{\CW}{\mathcal{W}} \newcommand{\CX}{\mathcal{X}} \newcommand{\CY}{\mathcal{Y}} \newcommand{\CZ}{\mathcal{Z}} \newcommand{\frA}{\mathfrak{A}} \newcommand{\frB}{\mathfrak{B}} \newcommand{\frC}{\mathfrak{C}} \newcommand{\frD}{\mathfrak{D}} \newcommand{\frE}{\mathfrak{E}} \newcommand{\frF}{\mathfrak{F}} \newcommand{\frG}{\mathfrak{G}} \newcommand{\frH}{\mathfrak{H}} \newcommand{\frI}{\mathfrak{I}} \newcommand{\frJ}{\mathfrak{J}} \newcommand{\frK}{\mathfrak{K}} \newcommand{\frL}{\mathfrak{L}} \newcommand{\frM}{\mathfrak{M}} \newcommand{\frN}{\mathfrak{N}} \newcommand{\frO}{\mathfrak{O}} \newcommand{\frP}{\mathfrak{P}} \newcommand{\frQ}{\mathfrak{Q}} \newcommand{\frR}{\mathfrak{R}} \newcommand{\frS}{\mathfrak{S}} \newcommand{\frT}{\mathfrak{T}} \newcommand{\frU}{\mathfrak{U}} \newcommand{\frV}{\mathfrak{V}} \newcommand{\frW}{\mathfrak{W}} \newcommand{\frX}{\mathfrak{X}} \newcommand{\frY}{\mathfrak{Y}} \newcommand{\frZ}{\mathfrak{Z}} \newcommand{\CNP}{\mathcal{NP}} \newcommand{\CPP}{\mathcal{PP}} \newcommand{\SP}{\mathsf{P}} \newcommand{\SPP}{\mathsf{PP}} \newcommand{\SSP}{\mathsf{\#P}} \newcommand{\SNP}{\mathsf{NP}} \newcommand{\SBPP}{\mathsf{BPP}} \newcommand{\ScoNP}{\mathsf{coNP}} \newcommand{\bbone}{\mathbbm{1}} \newcommand{\ord}{\mathrm{ord}} \newcommand{\odr}{\vee} \newcommand{\und}{\wedge} \newcommand{\Odr}{\bigvee} \newcommand{\Und}{\bigwedge} \newcommand{\xor}{\oplus} \newcommand{\Xor}{\bigoplus} \newcommand{\bmat}[1]{\begin{bmatrix} #1 \end{bmatrix}} \DeclareMathOperator*{\argmin}{argmin} \DeclareMathOperator*{\argmax}{argmax}\]]]></summary></entry><entry><title type="html">Danger and Potential of AI assistants</title><link href="https://swaeldchen.github.io/blog/2023/AI_Assistent/" rel="alternate" type="text/html" title="Danger and Potential of AI assistants"/><published>2023-01-03T00:00:00+01:00</published><updated>2023-01-03T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/AI_Assistent</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/AI_Assistent/"><![CDATA[<p>*TL;DR: At some point most people will have an AI assistent with which we will build a (para-)social relationship. This adds to the weight of AI doom scnearios, but also might allow for more venues for alignment.</p> <p>###</p>]]></content><author><name>Stephan Wäldchen</name></author><category term="research"/><category term="optimization"/><category term="ml"/><category term="uniform convexity"/><category term="abstract"/><summary type="html"><![CDATA[*TL;DR: At some point most people will have an AI assistent with which we will build a (para-)social relationship. This adds to the weight of AI doom scnearios, but also might allow for more venues for alignment.]]></summary></entry><entry><title type="html">AI safety - An Overview</title><link href="https://swaeldchen.github.io/blog/2023/AI_Safety/" rel="alternate" type="text/html" title="AI safety - An Overview"/><published>2023-01-03T00:00:00+01:00</published><updated>2023-01-03T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/AI_Safety</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/AI_Safety/"><![CDATA[<p>Jump to <a style="font-weight:bold" href="/agenda">my Agenda.</a></p> <h3 id="what-is-ai-safety">What is AI safety?</h3> <p>People who create AIs do the following thing: take a model architecture, combine it with a training procedure and out comes an artificial intelligence. If the AI that comes out is capable enough, it could be very dangerous to humans unless it has certain properties that prevent that.</p> <p>AI Safety aims to answer the following questions:</p> <ol> <li>What properties do we want the AI to have?</li> <li>How can we measure whether it has those properties?</li> <li>How can we ensure these properties through the architecture and training setup?</li> </ol> <p>The possible properties fall broadly into two classes:</p> <ol> <li>Behavioural:, e.g. capability, corrigibility, robustness, ethics, thruthfulness</li> <li>Internal: e.g. interpretability, goal orientedness, reasoning process, correctness of implicit world models</li> </ol> <p>The behavioural properties are what we can principally observe when the model acts and also what we primarily care about. In a certain sense, we do not necessarily care about how the AI operates internally as long as it does what we want. However, to ensure that it will continue to do what we want under many unforseen circumstances the internal properties matter a great deal to us.</p> <p><strong>Example:</strong></p> <p>We want our AI to answer questions truthfully. We can test the truthfulness on questionaires. We can measurably increase the truthfulness via incorporating Reinforcement Learning from Human Feedback into the training process, see e.g. <a href="https://arxiv.org/pdf/2203.02155.pdf">here</a>. Another example is that the AI’s reasoning should be interpretable to us.</p> <h3 id="what-should-alignment-research-look-like">What should alignment research look like?</h3> <ol> <li>Conceptualise new properties X that we should want an AI to have.</li> <li>Design tests that quantify whether trained AIs have X.</li> <li>Relate X to existing training paradigms and investigate why it might not be trained for X.</li> <li>Find the best training setup possible to enforce X under reasonable resource constraints.</li> </ol>]]></content><author><name>Stephan Wäldchen</name></author><category term="research"/><category term="AI safety"/><category term="concepts"/><summary type="html"><![CDATA[Jump to my Agenda.]]></summary></entry><entry><title type="html">Pain, Peace and Pleasure</title><link href="https://swaeldchen.github.io/blog/2023/Pain_Peace_Pleasure/" rel="alternate" type="text/html" title="Pain, Peace and Pleasure"/><published>2023-01-03T00:00:00+01:00</published><updated>2023-01-03T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/Pain_Peace_Pleasure</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/Pain_Peace_Pleasure/"><![CDATA[<p>*TL;DR:</p> <h3 id="on-a-personal-note">On a personal note</h3> <p>The last seven years have been very painful for me, both mentally and physically. Due to my health prolems I experience both</p> <p>One thing that I noticed is that pain brings our</p> <p>One thing that I noticed is that the brain deals with the pain either by actionism or withdrawing. In both cases the underlying</p> <h3 id="what-do-i-mean-by-pain">What do I mean by pain?</h3> <p>Much more than</p> <p>y:</p> <ol> <li>Try to identify the reason for the pain</li> <li>Make a plan how to overcome the pain</li> <li>Imagine a future without the pain</li> </ol> <p>This is mostly reasonable, since most pain is one that we can react to, like stepping on a sharp object.</p> <p>The problem: Some pain cannot really be rectified. But our brain is mostly in problem solving mode,</p> <h3 id="the-role">The Role</h3> <h3 id="techniques-to-increase-your-pain-tolerance">Techniques to increase your pain tolerance</h3> <p>. Body Scan or Self-Listening Meditation . Resistence Training . Focused</p>]]></content><author><name>Stephan Wäldchen</name></author><category term="wisdom"/><category term="health"/><category term="inner peace"/><summary type="html"><![CDATA[*TL;DR:]]></summary></entry><entry><title type="html">Interactive Classification 1: Preliminaries</title><link href="https://swaeldchen.github.io/blog/2023/FI_Preliminaries/" rel="alternate" type="text/html" title="Interactive Classification 1: Preliminaries"/><published>2023-01-02T00:00:00+01:00</published><updated>2023-01-02T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/FI_Preliminaries</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/FI_Preliminaries/"><![CDATA[<p>This post is part 1 of my series on <a href="/blog/2023/FI_start/">Interactive Classification</a>.</p> <p><strong>TL;DR:</strong> We present an overview of the current approaches and hurdles for formal interpretability:</p> <ol> <li>Feature Importance Attribution</li> <li>Shapley Values, Prime Implicants and Maximum Mutual Information</li> <li>The Modelling Problem and Manipulating Explanations </li> </ol> <style>.figcap{font-size:.9em}</style> <h3 id="interpretable-ai">Interpretable AI</h3> <p>An interpretable AI systems allows the human user to understand its reasoning process. Examples are decision trees, sparse lnear models and \(k\)-nearest neighbors.</p> <p>The standard bearer of modern machine learning, the <strong>Neural Networks</strong>, while achieving unprecedented accuracy, is nevertheless considered a <strong>black box</strong>, which means its reasoning is not made explicit. While we mathetically understand exactly what is happening in a single neuron, the interplay of thousands of these neurons results in behaviour that cannot be predicted straigtforward way. Compare this with how we exactly understand how an AND-gate and a NOT-gate work and how each program of finite length can be expressed as a series of these gates, yet we cannot understand a program just from reading the cuircuit plan.</p> <p>Interpretability research aims to remedy this fact by accompanying a decision, e.g. such as a classification, with addititional information that describes the reasoning process.</p> <p>One of the most prominent approaches is feature importance maps, which, for a given input, rate the input features for their imporatance to the model output.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/decision_list.png" alt="img1" style="float:center; margin-right: 5%; width:95%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 1.</strong> An example of a decision list taken from <a class="citation" href="#rudin2019stop">(Rudin, 2019)</a> used to predict whether a delinquent will be arrested again. The reasoning of the decision list is directly readable.)</p> <h3 id="feature-importance-attribution">Feature Importance Attribution</h3> <p>For a given classifier and an input, <strong>feature importance attribution</strong> (FIA) or feature importance map aims to highlight what part of the input is relevant for the classifier decision on this input. The idea is that generally only a small part of the input is actually important. If for example a neural network decides whether an image contains a cat or a dog, only the part of the image displaying the respectiv animal should be considered important. This consideration omits in which way the important features were considered. It can thus be seen as the <strong>lowest level</strong> of the reasoning process.</p> <p>There are quite a lot of practical approaches that derive feature importance values for neural networks, see <a class="citation" href="#mohseni2021multidisciplinary">(Mohseni et al., 2021)</a>. However, these methods are defined purely <strong>heuristically</strong>. They come without any defined target properties for the produced attributions. Furthermore, it has been demonstrated that these methods can be <strong>manipulated</strong> by clever designs of the neural network.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/lrp_example.png" alt="img1" style="float:center; margin-right: 5%; width:80%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 1.</strong> Feature importance map generated with LRP for a Fisher Vector Classifier (FV) and a Deep Neural Network (DNN). One can see that the FV decides the boat class based mostly on the water. Will this classifier generalise to boats without water? From <a class="citation" href="#lapuschkin2016analyzing">(Lapuschkin et al., 2016)</a>.</p> <h3 id="manipulation-of-heuristic-feature-importance">Manipulation of Heuristic Feature Importance</h3> <p>We are talking about manipulations in the follwing sense: Given that I have a neural network classifier \(\Phi\) that performs well for my purposes, I want another classifier \(\Phi^\prime\) that performs equally well but with a completely arbitrary feature importance.</p> <p>These heuristic FIAs all make implicit assumptions on the data distribution (some of them do that in a layer-wise fashion), see <a class="citation" href="#lundberg2017unified">(Lundberg &amp; Lee, 2017)</a>.</p> <p>All these heuristic explanation methods can be manipulated with the same trick: Basically keep the on-manifold behaviour constant, but change the off-manifold behaviour to influence the interpretations.</p> <p>Example from <a class="citation" href="#slack2020fooling">(Slack et al., 2020)</a>: \(\Phi\) is a discriminatory classifier, \(\Psi\) is a completely fair classifier and there is a helper function that decides if an input is on-manifold, belongs to a subspace of typical sample \(\mathcal{X}\). They define</p> \[\Phi^\prime(\mathbf{x}) = \begin{cases} \Phi(\mathbf{x}) &amp; \text{if}~ \mathbf{x}\in \mathcal{X}, \\ \Psi(\mathbf{x}) &amp; \text{otherwise.} \end{cases}\] <p>Now \(\Phi^\prime\) will almost always discriminate since for \(\mathbf{x}\) that lie on the manifold, whereas the explanations will be dominated by the fair classifier \(\Psi\), since most samples for the explanations are not on manifold. Thus the FIA highlights the innocuous features instead of the discriminatory ones.</p> <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/off-manifold.png" alt="img1" style="width:50%"/> </div> <p class="figcap"><strong>Figure 1.</strong> On-manifold data samples (blue) and off-manifold LIME-samples (red) for the COMPAS dataset; from <a class="citation" href="#dimanov2020you">(Dimanov et al., 2020)</a>.</p> <p>Formal approaches to interpretability thus need to make the underlying data distribution explicit.</p> <h3 id="formal-definition-of-feature-importance">Formal definition of feature importance</h3> <p>There are three main approaches to feature importance attribution:</p> <ol> <li>Shapley values</li> <li>Prime Implicants</li> <li>Maximal Mutual Information While Shapley values directly give a score to each feature, prime implicants and maximum mutual information select a subset of the features as <strong>the important features</strong>. However, since most search methods for these subsets work over convex relaxations of set membership, the unthresholded scores can serve as an importance value.</li> </ol> <p><strong>Shapley Values</strong> are a value attribution method from cooperative game theory. It is the unique are the unique method that satisfies the following desirable properties: linearity, symmetry, null player and efficiency <a class="citation" href="#shapley1997value">(Shapley, 1997)</a>. The idea is that a set of players achieve a common value. This value is to be fairly distributed to the players according to their importance. For this one considers every possible subset of players, called a coalition and the value this coalition would achieve. Thus, to define Shapley Values one needs a so called <em>characteristic function</em>, a value function that is defined on a set as well as all possible subsets. For \(d\) players, let \(\nu: 2^{[d]} \rightarrow \mathbb{R}\). Then \(\phi_i\), the Shapley value of the \(i\)-th player is defined as</p> \[\phi_{\nu,i} = \sum_{S \subseteq [d]\setminus\{i\}} \begin{pmatrix} d-1 \\ |S| \end{pmatrix}^{-1} ( \nu(S \cup \{i\}) - \nu(S) ).\] <p>Thus the Shapley values sum over all marginal contributions of the \(i\)-th player for ever possible coalition. In machine learning, the players correspond to features and the coalitions to subsets of the whole input. The explicite training of a characteristic function has been used in the context of simple two-player games to compare with heuristic attribution methods in <a class="citation" href="#waldchen2022training2">(Wäldchen et al., 2022)</a>. However, generally in machine learning, the model cannot evaluate subsets of inputs. For a given input \(\mathbf{x}\) and classification function \(f\), define \(\nu\) over expectation values:</p> \[\nu_{f,\mathbf{x}}(S) = \mathbb{E}_{\mathbf{y}\sim \mathcal{D}}[f(\mathbf{y})\,|\, \mathbf{y}_S = \mathbf{x}_S ] = \mathbb{E}_{\mathbf{y}\sim \mathcal{D}|_{\mathbf{x}_S}}[f(\mathbf{y})].\] <div style="display: flex; justify-content: center;"> <img src="https://swaeldchen.github.io/assets/img/merlin_arthur/Shapley.png" alt="img1" style="float:center; margin-right: 1%; width:100%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 1.</strong> Illustration of the idea of Shapley Values. For three players the pay-off for each possible coalition is shown. <a href="https://clearcode.cc/blog/game-theory-attribution/">Source</a></p> <p><strong>Prime Implicants</strong></p> <p>A series of appraoches considers hwo much a subset of the features of \(\mathbf{x}\) already determine the function output \(f(\mathbf{x})\). One of the most straight-forward approaches are the prime implicant explanations [D] for Boolean classifiers. An implicant is a part of the input that determines the output of the function completely, no matter which value the rest of the input takes. A prime implicant is an implicant that cannot be reduced further by omitting features.</p> <p>This concept is tricky to implement for very the highly non-linear neural networks, as small parts of an input can often be manipulated to give a completely different classification, see <a class="citation" href="#brown2017adversarial">(Brown et al., 2017)</a>. Thus, prime implicant explanations need to cover almost the whole input, and are thus not very informative.</p> <p>Probabilistic prime implicants have thus be introduced. As a relaxed notion, they only require the implicant to determine the function output with some high probability \(\delta\), see <a class="citation" href="#waldchen2021computational2">(Wäldchen et al., 2021)</a>, and in <a class="citation" href="#ribeiro2018anchors">(Ribeiro et al., 2018)</a> as <strong>precision</strong>:</p> \[\text{Pr}_{f,\mathbf{x}}(S) = \mathbb{P}_{\mathbf{y} \sim \mathcal{D}}[f(\mathbf{y}) = f(\mathbf{x}) ~|~ \mathbf{x}=\mathbf{y}].\] <p>For continuously valued fucntions \(f\) this can be further relaxed to being close to the original value in some fitting norm. One is then often interested in the most informative subset of a given maximal size:</p> \[S^* = \text{argmin}_{S: |S|\leq k} D_{f,\mathbf{x}}(S) \quad \text{where} \quad D_{f,\mathbf{x}}(S) = \|f(\mathbf{x}) - \mathbb{E}_{\mathbf{y}\sim \mathcal{D}|_{\mathbf{x}_S}}[f(\mathbf{y}) ]\|\] <p>In the language of Shapley values, we are looking for a small coalition that already achieves a value close to the whole set of players. There is a natural trade-off between the maximal set size \(k\) and the achievable distortion \(D(S^*)\).</p> <p>This concept can be refined without the arbitrariness of the norm by considering the mutual information.</p> <p><strong>Maximal Mutual Information</strong></p> <p>Mututal information measures the mutual dependence between two variables. In the context of the inpt features, it can be defined for a given subset S as as</p> \[I_{\mathbf{x} \sim \mathcal{D}}[f(\mathbf{x}); \mathbf{x}_S] = H_{\mathbf{x} \sim \mathcal{D}}[f(\mathbf{x})] - H_{\mathbf{x} \sim \mathcal{D}}[f(\mathbf{x}) ~|~ \mathbf{x}_S],\] <p>where \(H_{\mathbf{x} \sim \mathcal{D}}[f(\mathbf{x})]\) is the a priori entropy of the classification decision and \(H_{\mathbf{x} \sim \mathcal{D}}[f(\mathbf{x}) ~|~ \mathbf{x}_S]\) is the conditional entropy given the input set. When the conditional entropy is close to zero, the mutual information takes its maximal value as the pure a priori entropy.</p> \[H_{\mathbf{x} \sim \mathcal{D}}[f(\mathbf{x}) ~|~ \mathbf{x}_S] = - \sum_{l} p_l \log(p_l) \quad \text{where} \quad p_l = \mathbb{P}_{\mathbf{y} \sim \mathcal{D}}[f(\mathbf{y}) = l ~|~ \mathbf{y}_S = \mathbf{x}_S],\] <p>where \(l\) runs over the domain of \(f\). Similarly to the prime implicant explanations, one is often interested to find a small subset of the input that ensures high mutual information with the output:</p> \[S^* = \text{argmax}_{S: |S|\leq k} I_{\mathbf{x} \sim \mathcal{D}}[f(\mathbf{x}); \mathbf{x}_S].\] <h2 id="the-modelling-problem">The modelling Problem</h2> <p>All three presented methods to calculate the conditional probabilities \(\mathcal{D}_{\mathbf{x}_S}\) for all subsets \(S\) in question. For synthetic datasets these probabilities can be known, for realistic datasets however, these probabilities require explicit modelling of the conditional data distribution. This has been achieved practically with variational autoencoders or generative adversarial networks. Let us call these approximations \(\mathcal{D^\prime}|_{\mathbf{x}_S}\).</p> <h4 id="practical-problems">Practical Problems</h4> <p>There are basically two practical approaches to the modelling problem. The <strong>first</strong> is taking a simplified <strong>i.i.d. distribution</strong> (which is in particular independent of the given features):</p> \[\mathbb{P}_{\mathbf{y}\sim\mathcal{D}}(\mathbf{y}_{S^c} ~|~ \mathbf{y}_S = \mathbf{x}_S) = \prod_{i \in S^c} p(y_i).\] <p>This has been the approach taken for example in <a class="citation" href="#fong2017interpretable">(Fong &amp; Vedaldi, 2017)</a>,<a class="citation" href="#macdonald2019rate2">(MacDonald et al., 2019)</a> and <a class="citation" href="#ribeiro2016model">(Ribeiro et al., 2016)</a>. The problem here is that for certain masks this can create features that are not there in the original image, see Figure 4 for an illustration. This can actually happen even when unintended in case of an optimiser solving for small distortion \(D_{f,\mathbf{x}}\), as shown in Figure 4.</p> <div style="display: flex; justify-content: center;"> <embed src="https://swaeldchen.github.io/assets/img/merlin_arthur/bird_mask.png" alt="img1" style="float:center; margin-right: 1%; width:50%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 4.</strong> The optimised mask to convince the classifier of the (correct) bird class constructs a feature that is not present in the original image, here a bird head looking to the left inside of the monochrome black wing of the original; from <a class="citation" href="#"></a>[Macdonald2021]. This can happen because of the effect explained in Figure 5 Left.</p> <p>In fact, these simplified models are the reason that the heuristic methods of LIME ans ShAP are manipulable as explained before. If they used a correct model of the data distribution, there would be no off-manifold inputs when calculating the importance valuese, and the trick to change the off-manifold behaviour of the classifier would be without effect.</p> <p>The <strong>second</strong>, data-driven approach is to train a <strong>generative model</strong> on the dataset:</p> \[\mathbb{P}_{\mathbf{y}\sim\mathcal{D}}(\mathbf{y}_{S^c} ~|~ \mathbf{y}_S = \mathbf{x}_S) = G(\mathbf{y}_{S^c}~;~ \mathbf{x}_{S}).\] <p>This has the advantage that the inpainting will likely be done more correctly thus evading the creation of new features by the mask. However, a new problem arises. Since it is likely that the classifier and the generator have been trained on the same dataset, they tend to learn the same biases which can cancel out and go undetected. An illustration is given in Figure 5 Right. The classifier learns to use water to identify ships. When a pixel mask containing the ship is selected, the generator paints the water back in, which can then be used by the classifier to answer correctly thus giving the appearance that the ship feature was used. This would give the ship high Shapley values and high mutual information, despite the classifier working in a way that will not generalise outside the dataset.</p> <div style="display: flex; justify-content: center;"> <embed src="https://swaeldchen.github.io/assets/img/merlin_arthur/failures.png" alt="img1" style="float:center; margin-right: 1%; width:50%"/> <p style="clear: both;"></p> </div> <p class="figcap"><strong>Figure 5.</strong> Different failure modes for different models of the data distribution. Both approaches have specific shortcomings. <em>Left:</em> Feature inpainting with an i.i.d. distribution. Selecting a mask can create a new feature that was not present in the original input. If one would consider a data-driven approach instead the rest of the image would likely be inpainted as black and the effect would disappear. <em>Right:</em> Data-driven inpainting. After selecting the boat feature, a trained generator inpaints the water back into the image, which the classifier uses for classification. Consequently the boat feature will get high Shaply Values/mutual information even though the classifier does not rely on boats. If one uses an i.i.d appraoch this effect would not appear.</p> <h4 id="theoretical-problems">Theoretical Problems</h4> <p>Since we want a formal approach with a bound on the calculated Shapley values, distortion or mutual information, we need a <strong>distance bound</strong> between \(\mathcal{D^\prime}|_{\mathbf{x}_S}\) and \(\mathcal{D}|_{\mathbf{x}_S}\) in some fitting norm, e.g. the total variation or Kullback-Leibler divergence</p> \[D_{\text{KL}}(\mathcal{D}|_{\mathbf{x}_S}, \mathcal{D^\prime}|_{\mathbf{x}_S}).\] <p>This is hard to achieve, since to establish such bounds one would need <strong>exponentially many samples</strong> from the dataset, since there are exponentially many subsets to condition on.</p> <p>Taking any image \(\mathbf{x}\) from ImageNet for example and conditioning on a subset \(S\) of pixels, there probably exists no second image with the same values on \(S\) when size of \(S\) is larger than 20. These conditional distributions thus cannot be sampled for most high-dimensional datasets and no quality bounds can be derived. <strong>One would need to trust one trained model to evaluate another trained model</strong> — this is a very strong condition for a formal guarantee!</p> <p>In the next post we discuss how this problem can be overcome by replacing the modelling of the data distribution with an adversarial setup.</p> <p><a href="/blog/2023/FI_start/">◀ Previous Post</a></p> <p align="right"><a href="/blog/2023/FI_Merlin-Arthur/"> Next Post &#9654;</a></p> <h3 id="references">References</h3> <ol class="bibliography"><li><div class="text-justify"> <span id="rudin2019stop">Rudin, C. (2019). Stop explaining black box machine learning models for high stakes decisions and use interpretable models instead. <i>Nature Machine Intelligence</i>, <i>1</i>(5), 206–215.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="mohseni2021multidisciplinary">Mohseni, S., Zarei, N., &amp; Ragan, E. D. (2021). A multidisciplinary survey and framework for design and evaluation of explainable AI systems. <i>ACM Transactions on Interactive Intelligent Systems (TiiS)</i>, <i>11</i>(3-4), 1–45.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="lapuschkin2016analyzing">Lapuschkin, S., Binder, A., Montavon, G., Muller, K.-R., &amp; Samek, W. (2016). Analyzing classifiers: Fisher vectors and deep neural networks. <i>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</i>, 2912–2920.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="lundberg2017unified">Lundberg, S. M., &amp; Lee, S.-I. (2017). A unified approach to interpreting model predictions. <i>Advances in Neural Information Processing Systems</i>, <i>30</i>.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="slack2020fooling">Slack, D., Hilgard, S., Jia, E., Singh, S., &amp; Lakkaraju, H. (2020). Fooling lime and shap: Adversarial attacks on post hoc explanation methods. <i>Proceedings of the AAAI/ACM Conference on AI, Ethics, and Society</i>, 180–186.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="dimanov2020you">Dimanov, B., Bhatt, U., Jamnik, M., &amp; Weller, A. (2020). <i>You shouldn’t trust me: Learning models which conceal unfairness from multiple explanation methods.</i></span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="shapley1997value">Shapley, L. S. (1997). A value for n-person games. <i>Classics in Game Theory</i>, <i>69</i>.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="waldchen2022training2">Wäldchen, S., Pokutta, S., &amp; Huber, F. (2022). Training characteristic functions with reinforcement learning: Xai-methods play connect four. <i>International Conference on Machine Learning</i>, 22457–22474.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="brown2017adversarial">Brown, T. B., Mané, D., Roy, A., Abadi Martı́n, &amp; Gilmer, J. (2017). Adversarial patch. <i>ArXiv Preprint ArXiv:1712.09665</i>.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="waldchen2021computational2">Wäldchen, S., Macdonald, J., Hauch, S., &amp; Kutyniok, G. (2021). The computational complexity of understanding binary classifier decisions. <i>Journal of Artificial Intelligence Research</i>, <i>70</i>, 351–387.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="ribeiro2018anchors">Ribeiro, M. T., Singh, S., &amp; Guestrin, C. (2018). Anchors: High-precision model-agnostic explanations. <i>Proceedings of the AAAI Conference on Artificial Intelligence</i>, <i>32</i>(1).</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="fong2017interpretable">Fong, R. C., &amp; Vedaldi, A. (2017). Interpretable explanations of black boxes by meaningful perturbation. <i>Proceedings of the IEEE International Conference on Computer Vision</i>, 3429–3437.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="macdonald2019rate2">MacDonald, J., Wäldchen, S., Hauch, S., &amp; Kutyniok, G. (2019). A rate-distortion framework for explaining neural network decisions. <i>ArXiv Preprint ArXiv:1905.11092</i>.</span> </div> <div> </div> <div> </div> </li> <li><div class="text-justify"> <span id="ribeiro2016model">Ribeiro, M. T., Singh, S., &amp; Guestrin, C. (2016). Model-agnostic interpretability of machine learning. <i>ArXiv Preprint ArXiv:1606.05386</i>.</span> </div> <div> </div> <div> </div> </li></ol>]]></content><author><name>Stephan Wäldchen</name></author><category term="research"/><category term="interpretability"/><category term="feature importance attribution"/><category term="fia"/><category term="modelling problem"/><summary type="html"><![CDATA[This post is part 1 of my series on Interactive Classification.]]></summary></entry><entry><title type="html">Interactive Classification 0: Overview</title><link href="https://swaeldchen.github.io/blog/2023/FI_start/" rel="alternate" type="text/html" title="Interactive Classification 0: Overview"/><published>2023-01-01T00:00:00+01:00</published><updated>2023-01-01T00:00:00+01:00</updated><id>https://swaeldchen.github.io/blog/2023/FI_start</id><content type="html" xml:base="https://swaeldchen.github.io/blog/2023/FI_start/"><![CDATA[<p>I am writing a series of posts on the subject on formal AI interpretability with focus on interpretability approaches that apply to neural networks leading up to our recent work on <strong>Merlin-Arthur Classifiers</strong>.</p> <ol> <li><a href="/blog/2023/FI_Preliminaries/">Preliminaries</a></li> <li><a href="/blog/2023/FI_Merlin-Arthur/">Prover-Verifier Setup</a></li> <li><a href="/blog/2023/FI_AFC/">Asymmetric Feature Correlation</a></li> <li><a href="/blog/2023/FI_Relative_Strength/">Relative Strength between Cooperative and Adversarial Prover</a></li> <li><a href="/blog/2023/FI_Complexity/">Computational Complexity</a></li> </ol>]]></content><author><name>Stephan Wäldchen</name></author><category term="research"/><category term="interpretability"/><category term="feature importance attribution"/><category term="fia"/><summary type="html"><![CDATA[I am writing a series of posts on the subject on formal AI interpretability with focus on interpretability approaches that apply to neural networks leading up to our recent work on Merlin-Arthur Classifiers.]]></summary></entry></feed>