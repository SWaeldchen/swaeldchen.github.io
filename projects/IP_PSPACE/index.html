<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Arithmetic Reinforcement Learning and Certifiable Game Plans | Stephan T. Wäldchen</title> <meta name="author" content="Stephan T. Wäldchen"> <meta name="description" content="Can we certify the plan of a powerful but possibly adversarial AI?"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/styles.css"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://swaeldchen.github.io/projects/IP_PSPACE/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Stephan </span>T. Wäldchen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Science</a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">Talks</a> </li> <li class="nav-item "> <a class="nav-link" href="/art/">Art</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Arithmetic Reinforcement Learning and Certifiable Game Plans</h1> <p class="post-description">Can we certify the plan of a powerful but possibly adversarial AI?</p> </header> <article> <p>This is my idea for a new AI alignment project. Basically, I want to answer the followign question:</p> <blockquote style="text-align:center; font-style:italic; color:#333;"> "Can a more powerful reasoner convince a human auditor of the validity of a plan, even in a complex environment?" </blockquote> <p>To make this work, we need to exploit some principle in the sense of “It’s easier to recognise that a proof is correct than to come up with a proof.” The first problem is $\mathsf{NP}$-hard, the latter can be solved in polynomial time.</p> <p>This point was recently raised by Max Tegmark in his Lex Fridman <a href="https://www.youtube.com/watch?v=VcVfceTsD0A&amp;t=1h44m30s" rel="external nofollow noopener" target="_blank">interview</a>.</p> <p>In case of using AI as theorem provers it is quite straightforward to ensure that it cannot convince a human of a wrong theorem. Foundations of mathematics, e.g. Zermelo-Fraenkel (+ axiom of choice), are a system of deterministic rules, called axioms. The AI can present a reduction of a theorem, for example for $\mathsf{P}\neq\mathsf{NP}$, as a list of intermediate theorems accompanied by the rule that allows one theorem to be derived by the next until it leads back to one fundamental axioms. It is straightforward to check that each rules was applied correctly in each reduction step.</p> <p>For most real-world plans there are complications however:</p> <ol> <li>Most transitions between world states are non-deterministic</li> <li>The world contains other intelligent agents, notably the AI itself.</li> <li>The world model of the AI (the transition rules), might be more accurate than the ones known to the human auditor.</li> <li>It is unclear how long the time horizon is that should be modelled.</li> </ol> <p>At least for the first two problems I can see a way towards a solution. So from now on, we assume that we are have perfect knowledge of how the environment works and only care about the result of the plan up to some finite time $T$.</p> <p>Two-player games (or multiplayer), even with probabilistic aspects, are $\mathsf{PSPACE}$-complete. As far as we can tell, $\mathsf{PSPACE}$-complete problems are not in $\mathsf{NP}$ and will not allow for a polynomially sized certificate. However, we can extend the discussion with the AI up to polynomially many rounds, which results in the complexity class $\mathsf{IP}$ or <em>Interactive Proofs</em>. Coincidentally, $\mathsf{IP}$ is exactly equal to $\mathsf{PSPACE}$.</p> <p>This equality is usually demonstrated by reducing TQBL (Totally Quantified Boolean Formulas, a $\mathsf{PSPACE}$-complete problem) to $\mathsf{IP}$, see <a href="https://en.wikipedia.org/wiki/IP_(complexity)#TQBF_is_a_member_of_IP" rel="external nofollow noopener" target="_blank">wikipedia</a>. This reduction involves as a crucial step aithmetisation of the Boolean logic and <a href="https://en.wikipedia.org/wiki/Polynomial_identity_testing" rel="external nofollow noopener" target="_blank">Polynomial Identity Testing (PIT)</a> via the <a href="https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma" rel="external nofollow noopener" target="_blank">Schwartz-Zippel algorithm</a> (basically sample randomly over a large-enough finite field). <a href="https://cs.brown.edu/courses/gs019/papers/ip.pdf" rel="external nofollow noopener" target="_blank">Here</a> is a detailed walk-through for the reduction.</p> <p>One can easily transform deterministic two-player games into TQBFs, see <a href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=Encoding+Connect-4+using+Quantified+Boolean+Formulae+Ian+P+Gent+and+Andrew+G+D+Rowley&amp;btnG=" rel="external nofollow noopener" target="_blank">here</a> for example. For non-deterministic games I am not fully sure of the procedure, but it should be possible, see <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwjBh_md2O3-AhXB4KQKHSpDA9g4FBAWegQICRAB&amp;url=https%3A%2F%2Fwww.fi.muni.cz%2Fusr%2Fkucera%2Fpapers%2Fqest07.ps&amp;usg=AOvVaw26TwTX8w9Em1wC-UHHo5Wu" rel="external nofollow noopener" target="_blank">here</a> and <a href="https://research-explorer.ista.ac.at/download/3846/5897/a_survey_of_stochastic_omega-regular_games.pdf" rel="external nofollow noopener" target="_blank">here</a>. The Boolean formula describes the game mechanic, i.e. what is the initial board situation, what kinds of moves are allowed and what is the win condition, in terms of binary variables.</p> <p>This TQBF can then be decided via the Interactive Proof reduction. Interestingly, the PIT consistency condition becomes very similar to a arithmetised version of the <a href="https://en.wikipedia.org/wiki/Bellman_equation" rel="external nofollow noopener" target="_blank">Bellman equation</a>. I will add further details to illustrate that point later. In principle we replace</p> \[Q(a_t, s_t) = r(a_t, s_t) + \max_{a_{t+1}} Q(a_{t+1}, x_{t+1}) \quad\rightarrow\quad Q(a_t, s_t) = \bigvee_{a_{t+1}} Q(a_{t+1}, x_{t+1}),\] <p>where $x \lor y = x + y - xy$, the arithmatisation of the logical OR. These return the same value, if there is only a binary reward for winning</p> \[r(a_t, s_t) = \begin{cases} 0 &amp; t&lt;T, \\ \text{is_win}(s_t) &amp; t = T, \end{cases}\] <p>and $Q(a_t, s_t) \in \{0,1\}$, so $Q$ always predicts a binary reward. Any game with intermediate reward can be turned into a game of binary reward, by just setting the win condition to $\sum_t r(a_t,s_t) \geq R_{\text{threshold}}$.</p> <p>I want to actually train an neural network-based agent to have arithmetic consistency via Reinforcement Learning and Gradient Descent.</p> <p><strong>Implementation:</strong></p> <ol> <li>Use a simple deterministic game with finite time horizon (e.g. tic-tac-toe, Connect-Four, Hex)</li> <li>Train an AI to predict the whether the player can still win given a board situation. Extend this AI to predict the polynomial coefficients for the polynomial identity test, given the previous random samples of the $\mathsf{IP}$-protocol as input.</li> <li>See how well the AI can be trained to actually fulfil the consistency checks.</li> </ol> <p><strong>How to do the arithmetic extension?</strong> I basically have three ideas how to do the arithmetic extension. None of them are super satisfactory yet.</p> <ol> <li>The straightforward way for implementation would be to let a ReLU-neural network represent a polynomial oracle. The input would be an assignment from the finite field to all but one variable, and the output would be the polynomial coefficients of the left over variable. However, this seems complicated to train, as the network would need to learn polynomial multiplication. One can make this easer by having quadratic activations functions additionally to the ReLU ones.</li> <li>Another way is to train a Neural Network with only quadratic activations which then represents a polynomial of degree exponential in the number of layers. However, one can do non-commutative identity testing, which appearently can <a href="https://arxiv.org/pdf/1606.00596.pdf" rel="external nofollow noopener" target="_blank">deal with exponential degrees and exponential number of terms</a>. I haven’t fully understood the paper though. <em>Edit:</em> I forgot that the number of terms can actually grow <strong>doubly</strong>-exponential for non-commutative fields. It feels like everything is conspiring to make this hard.</li> <li>Another appraoch would be to use tensor networks instead of neural networks. Tensor networks can represent exponentially large polynomials of bounded degree. However, that would go against the leading paradigm of DNN-based learning.</li> </ol> <p><strong>Questions:</strong></p> <ol> <li>Is there a better appraoch that does not require learning polynomial coefficients?</li> <li>If not, can a neural network architecture learn to predict the right polynomial coefficients? Since the coefficients are from a finite field, there is some room to correct errors.</li> <li>Can the whole methods be made robust for a system that makes mistakes sometimes? Could this involve relaxing the consistency condition?</li> <li>Can this be scaled up to more compled games?</li> <li>How can we extend this to non-deterministic games?</li> </ol> <p><strong>Reasons why I believe this might work:</strong></p> <ol> <li>Neural networks have become quite good at grokking abstract reasoning tasks,</li> <li>As the reasoning capabilities of AI grows, certifying the game plan will become easier, even if the AI comes up with more complicated plans, since it becomes easier to implement the PIT.</li> </ol> </article> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> © Copyright 2024 Stephan T. Wäldchen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>